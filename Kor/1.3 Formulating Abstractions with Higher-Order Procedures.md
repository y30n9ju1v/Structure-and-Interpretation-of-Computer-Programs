이 글은 '고차 프로시저(Higher-Order Procedures)'를 이용해서 좀 더 추상적인 개념을 표현하는 방법에 대한 내용이야.

우리가 프로시저가 숫자에 대한 복잡한 연산을 특정 숫자에 구애받지 않고 추상적으로 설명하는 역할을 한다는 것을 배웠어. 예를 들어, `(define (cube x) (* x x x))` 이렇게 `cube` 프로시저를 정의하면, 특정 숫자의 세제곱이 아니라 '어떤 숫자든 세제곱을 구하는 방법'에 대해 이야기하는 거지. 물론 이 프로시저를 굳이 정의하지 않고 필요할 때마다 `(* 3 3 3)`, `(* x x x)` 이렇게 직접 쓸 수도 있겠지. 하지만 이렇게 하면 우리는 언어의 기본 기능(이 경우 곱셈) 수준에서만 작업하게 되어 매우 불리해져. 우리는 세제곱을 계산할 수는 있지만, '세제곱하기'라는 개념 자체를 표현할 수는 없게 되는 거야. 강력한 프로그래밍 언어라면 공통된 패턴에 이름을 붙여서 추상화를 만들고, 그 추상화를 직접 다룰 수 있는 능력이 있어야 해. 프로시저가 바로 이 능력을 제공하는 거지. 그래서 가장 기본적인 언어를 제외한 모든 프로그래밍 언어에는 프로시저를 정의하는 메커니즘이 포함되어 있어.

하지만 숫자를 매개변수로 받는 프로시저에만 제한된다면, 수치 처리에서도 추상화를 만드는 능력은 심각하게 제한될 거야. 종종 동일한 프로그래밍 패턴이 여러 다른 프로시저와 함께 사용되곤 하거든. 이런 패턴들을 개념으로 표현하려면, 인자로 프로시저를 받거나 값으로 프로시저를 반환할 수 있는 프로시저를 만들어야 해. 프로시저를 조작하는 프로시저를 '고차 프로시저(higher-order procedures)'라고 불러. 이 섹션에서는 고차 프로시저가 어떻게 강력한 추상화 메커니즘이 될 수 있는지, 그리고 우리 언어의 표현력을 엄청나게 증가시킬 수 있는지 보여줄 거야.

### 1.3.1 인자로 쓰이는 프로시저 (Procedures as Arguments)

다음 세 가지 프로시저를 보자. 첫 번째는 `a`부터 `b`까지의 정수 합을 계산해.

Code snippet

```
(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))
```

두 번째는 주어진 범위의 정수들의 세제곱 합을 계산해.

Code snippet

```
(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))
```

세 번째는 pi/8로 수렴하는 (매우 느리게) 다음 급수에서 일련의 항들의 합을 계산해.

$$\frac{1}{1 \cdot 3} + \frac{1}{5 \cdot 7} + \frac{1}{9 \cdot 11} + {\ldots,}$$

Code snippet

```
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))
```

이 세 프로시저는 분명히 공통적인 기본 패턴을 공유하고 있어. 대부분 동일하고, 프로시저의 이름, 더할 항을 계산하는 데 사용되는 `a`의 함수, 그리고 `a`의 다음 값을 제공하는 함수에서만 달라. 같은 틀에 구멍을 채워 넣는 방식으로 각 프로시저를 만들 수 있어.

Code snippet

```
(define (⟨이름⟩ a b)
  (if (> a b)
      0
      (+ (⟨항⟩ a)
         (⟨이름⟩ (⟨다음⟩ a) b))))
```

이러한 공통 패턴의 존재는 유용한 추상화가 드러나기를 기다리고 있다는 강력한 증거야. 실제로 수학자들은 오래전에 '급수의 합'이라는 추상화를 식별하고, 예를 들어 $\sum_{n = a}^{b}f(n) = f(a) + \cdots + f(b)$와 같은 "시그마 표기법"을 발명하여 이 개념을 표현했어. 시그마 표기법의 힘은 수학자들이 특정 합만 다루는 것이 아니라 합 자체의 개념을 다룰 수 있게 해준다는 점이야. 예를 들어, 특정 급수에 구애받지 않는 합에 대한 일반적인 결과를 공식화할 수 있지.

마찬가지로, 프로그램 설계자로서 우리는 특정 합을 계산하는 프로시저만 만드는 것이 아니라, 합이라는 개념 자체를 표현하는 프로시저를 작성할 수 있을 만큼 우리 언어가 강력하기를 원해. 위에서 보여준 공통적인 틀을 사용하여 "구멍"들을 형식 매개변수로 바꾸면 우리 절차 언어에서 쉽게 그렇게 할 수 있어.

Code snippet

```
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
```

`sum`은 `a`와 `b`의 하한과 상한뿐만 아니라 `term`과 `next` 프로시저를 인자로 받는다는 점에 주목해. 우리는 `sum`을 다른 프로시저처럼 사용할 수 있어. 예를 들어, `sum-cubes`를 정의하기 위해 `sum`을 (인자를 1씩 증가시키는 `inc` 프로시저와 함께) 사용할 수 있어.

Code snippet

```
(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))
```

이것을 사용하면 1부터 10까지의 정수 세제곱의 합을 계산할 수 있어.

Code snippet

```
(sum-cubes 1 10)
3025
```

항을 계산하기 위한 항등 프로시저의 도움으로, `sum-integers`를 `sum`으로 정의할 수 있어.

Code snippet

```
(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))
```

그러면 1부터 10까지의 정수를 더할 수 있어.

Code snippet

```
(sum-integers 1 10)
55
```

`pi-sum`도 같은 방식으로 정의할 수 있어.

Code snippet

```
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
```

이 프로시저들을 사용하여 pi의 근사치를 계산할 수 있어.

Code snippet

```
(* 8 (pi-sum 1 1000))
3.139592655589783
```

일단 `sum`이 있으면, 이것을 building block으로 사용하여 더 많은 개념을 공식화할 수 있어. 예를 들어, 함수 f의 a와 b 사이의 정적분은 작은 dx 값에 대해 다음 공식을 사용하여 수치적으로 근사할 수 있어.

$${\int_{a}^{b}\mspace{-5mu} f}\; = \;\left\lbrack \; f\left( a + \frac{dx}{2} \right) \right.\, + \,{f\left( a + dx + \frac{dx}{2} \right)}\, + \,{\left. f\left( a + 2dx + \frac{dx}{2} \right)\, + \,\ldots\; \right\rbrack dx}$$

이것을 직접 프로시저로 표현할 수 있어.

Code snippet

```
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

(integral cube 0 1 0.01)
.24998750000000042

(integral cube 0 1 0.001)
.249999875000001
```

(0과 1 사이에서 `cube`의 적분 정확한 값은 1/4이야.)

**연습문제 1.29:** 심슨 법칙은 위에서 설명한 방법보다 더 정확한 수치 적분 방법이야. 심슨 법칙을 사용하여 함수 f의 a와 b사이의 적분은 다음으로 근사할 수 있어.

$$\frac{h}{3}(y_{0} + {4y_{1}} + {2y_{2}} + {4y_{3}} + {2y_{4}} + \cdots + {2y_{n - 2}} + {4y_{n - 1} + y_{n}),}$$

여기서 $h = (b - a)/n$ 이고, n은 짝수 정수, $y_{k} = {f(a + kh)}$야. (n을 증가시키면 근사치의 정확도가 높아져.) 인자로 f, a, b, 그리고 n을 받아서 심슨 법칙을 사용하여 계산된 적분 값을 반환하는 프로시저를 정의해봐. 네 프로시저를 사용하여 `cube`를 0과 1 사이에서 적분(n=100과 n=1000으로)하고, 그 결과를 위에서 보여준 `integral` 프로시저의 결과와 비교해봐.

**연습문제 1.30:** 위에 있는 `sum` 프로시저는 선형 재귀를 생성해. 이 프로시저는 합이 반복적으로 수행되도록 다시 작성할 수 있어. 다음 정의에서 빠진 표현식을 채워서 이걸 어떻게 하는지 보여봐.

Code snippet

```
(define (sum term a next b)
  (define (iter a result)
    (if ⟨??⟩
        ⟨??⟩
        (iter ⟨??⟩ ⟨??⟩)))
  (iter ⟨??⟩ ⟨??⟩))
```

**연습문제 1.31:**

1. `sum` 프로시저는 고차 프로시저로 포착할 수 있는 수많은 유사한 추상화 중 가장 간단한 것일 뿐이야. 주어진 범위의 여러 지점에서 함수의 값들의 곱을 반환하는 `product`라는 유사한 프로시저를 작성해봐. `factorial`을 `product`를 사용하여 어떻게 정의할 수 있는지 보여봐. 또한 다음 공식을 사용하여 pi의 근사치를 계산하기 위해 `product`를 사용해봐.
    

$$\frac{\pi}{4}\, = \,{\frac{2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \cdot \cdots}{3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \cdot \cdots}.}$$

2. 만약 네 `product` 프로시저가 재귀 과정을 생성한다면, 반복 과정을 생성하는 프로시저를 작성해봐. 만약 반복 과정을 생성한다면, 재귀 과정을 생성하는 프로시저를 작성해봐.
    

**연습문제 1.32:**

1. `sum`과 `product` (1.31번 연습문제)는 둘 다 어떤 일반적인 누적 함수를 사용하여 용어들의 컬렉션을 결합하는 `accumulate`라는 훨씬 더 일반적인 개념의 특별한 경우임을 보여봐.
    
    Code snippet
    
    ```
    (accumulate
     combiner null-value term a next b)
    ```
    
    `accumulate`는 `sum`과 `product`와 동일한 용어 및 범위 사양과 함께, 현재 용어를 이전 용어들의 누적과 어떻게 결합해야 하는지 지정하는 `combiner` 프로시저(두 인자)와 용어가 소진되었을 때 사용할 기본 값을 지정하는 `null-value`를 인자로 받아. `accumulate`를 작성하고 `sum`과 `product`가 모두 `accumulate`에 대한 간단한 호출로 어떻게 정의될 수 있는지 보여봐.
    
2. 만약 네 `accumulate` 프로시저가 재귀 과정을 생성한다면, 반복 과정을 생성하는 프로시저를 작성해봐. 만약 반복 과정을 생성한다면, 재귀 과정을 생성하는 프로시저를 작성해봐.
    

**연습문제 1.33:** `accumulate`의 더 일반적인 버전을 얻을 수 있어 (1.32번 연습문제). 결합할 용어에 '필터(filter)' 개념을 도입해서 말이야. 즉, 지정된 조건을 만족하는 범위의 값에서 파생된 용어만 결합하는 거지. 결과로 나온 `filtered-accumulate`추상화는 accumulate와 동일한 인수를 받는데, 필터를 지정하는 한 인수의 추가적인 술어(predicate)가 있어. `filtered-accumulate`를 프로시저로 작성해봐. `filtered-accumulate`를 사용하여 다음을 어떻게 표현할 수 있는지 보여봐.

1. a부터 b 사이의 소수들의 제곱의 합 (이미 `prime?` 술어가 작성되어 있다고 가정함)
    
2. n보다 작고 n과 서로소인 모든 양의 정수들의 곱 (즉, $\text{GCD}(i,n) = 1$ 인 모든 양의 정수 $i < n$).
    

### 1.3.2 `Lambda`를 사용하여 프로시저 구성하기 (Constructing Procedures Using `Lambda`)

1.3.1에서 `sum`을 사용하는 데 있어서 `pi-term`이나 `pi-next`와 같은 사소한 프로시저들을 고차 프로시저의 인자로 사용하기 위해 정의해야 하는 것이 엄청나게 어색하게 느껴질 거야. `pi-next`와 `pi-term`을 정의하는 대신, "입력 값을 4 증가시키는 프로시저"와 "입력 값에 (입력 값 + 2)를 곱한 값의 역수를 반환하는 프로시저"를 직접 지정하는 방법이 더 편리할 거야. 우리는 프로시저를 생성하는 특별 형식 `lambda`를 도입하여 이것을 할 수 있어. `lambda`를 사용하면 우리가 원하는 것을 다음과 같이 설명할 수 있어.

Code snippet

```
(lambda (x) (+ x 4))
```

그리고

Code snippet

```
(lambda (x) (/ 1.0 (* x (+ x 2))))
```

그러면 `pi-sum` 프로시저는 어떤 보조 프로시저도 정의하지 않고도 다음과 같이 표현될 수 있어.

Code snippet

```
(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
```

다시 `lambda`를 사용하여 `integral` 프로시저를 보조 프로시저 `add-dx`를 정의할 필요 없이 작성할 수 있어.

Code snippet

```
(define (integral f a b dx)
  (* (sum f (+ a (/ dx 2.0))
            (lambda (x) (+ x dx))
            b)
     dx))
```

일반적으로 `lambda`는 `define`과 동일한 방식으로 프로시저를 생성하는 데 사용되는데, 프로시저의 이름이 지정되지 않는다는 점만 달라.

Code snippet

```
(lambda (⟨형식-매개변수들⟩) ⟨본문⟩)
```

그 결과로 나오는 프로시저는 `define`을 사용하여 생성된 프로시저와 똑같이 프로시저야. 유일한 차이점은 환경에서 어떤 이름과도 연결되어 있지 않다는 점이야. 사실,

Code snippet

```
(define (plus4 x) (+ x 4))
```

는 다음와 동일해.

Code snippet

```
(define plus4 (lambda (x) (+ x 4)))
```

`lambda` 표현식을 다음과 같이 읽을 수 있어.

Code snippet

```
(lambda                     (x)     (+   x     4))
    |                        |       |   |     |
the procedure of an argument x that adds x and 4
```

프로시저를 값으로 가지는 다른 표현식과 마찬가지로, `lambda` 표현식은 다음 조합에서 연산자로 사용될 수 있어.

Code snippet

```
((lambda (x y z) (+ x y (square z))) 1 2 3)
12
```

또는 더 일반적으로, 우리가 보통 프로시저 이름을 사용하는 모든 상황에서 사용할 수 있지.

#### `let`을 사용하여 지역 변수 만들기 (`Using` let `to create local variables`)

`lambda`의 또 다른 용도는 '지역 변수'를 만드는 데 있어. 우리는 종종 형식 매개변수로 바인딩된 변수 외에 다른 지역 변수가 필요할 때가 많아. 예를 들어, ${f(x,y)}\, = \,{x(1 + xy)^{2}} + {y(1 - y)} + {(1 + xy)(1 - y),}$ 함수를 계산하고 싶다고 가정해 보자. 이 함수는 다음과 같이 표현할 수도 있어.

$$\begin{array}{lll}
a & = & {1 + xy,} \\
{\phantom{(x,y)}b} & = & {1 - y,} \\
{f(x,y)} & = & {{xa^{2}} + {yb} + {ab.}} \\
\end{array}$$

f를 계산하는 프로시저를 작성할 때, x와 y뿐만 아니라 a와 b와 같은 중간 양의 이름도 지역 변수로 포함하고 싶어. 이를 달성하는 한 가지 방법은 보조 프로시저를 사용하여 지역 변수를 바인딩하는 거야.

Code snippet

```
(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))
```

물론, `lambda` 표현식을 사용하여 지역 변수를 바인딩하는 익명 프로시저를 지정할 수도 있어. 그러면 `f`의 본문은 해당 프로시저에 대한 단일 호출이 돼.

Code snippet

```
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
```

이 구조는 너무 유용해서 더 편리하게 사용할 수 있도록 `let`이라는 특별한 형식이 있어. `let`을 사용하면 `f` 프로시저는 다음과 같이 작성될 수 있어.

Code snippet

```
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
```

`let` 표현식의 일반적인 형태는 다음과 같아.

Code snippet

```
(let ((⟨var₁⟩ ⟨exp₁⟩)
      (⟨var₂⟩ ⟨exp₂⟩)
      …
      (⟨varₙ⟩ ⟨expₙ⟩))
  ⟨본문⟩)
```

이것은 다음과 같이 말하는 것으로 생각할 수 있어.

Code snippet

```
⟨var₁⟩은 ⟨exp₁⟩ 값을 가지고
⟨var₂⟩는 ⟨exp₂⟩ 값을 가지고
…
⟨varₙ⟩은 ⟨expₙ⟩ 값을 가진다
그 다음에 ⟨본문⟩을 실행한다
```

`let` 표현식의 첫 번째 부분은 이름-표현식 쌍의 목록이야. `let`이 평가될 때, 각 이름은 해당 표현식의 값과 연결돼. `let`의 본문은 이 이름들이 지역 변수로 바인딩된 상태에서 평가돼. 이것이 발생하는 방식은 `let` 표현식이 다음의 대체 구문으로 해석된다는 거야.

Code snippet

```
((lambda (⟨var₁⟩ … ⟨varₙ⟩)
   ⟨본문⟩)
 ⟨exp₁⟩
 …
 ⟨expₙ⟩)
```

지역 변수를 제공하기 위해 인터프리터에 새로운 메커니즘이 필요하지 않아. `let` 표현식은 단순히 기본 `lambda` 적용을 위한 '문법적 설탕(syntactic sugar)'일 뿐이야.

이러한 동등성으로부터, `let` 표현식에 의해 지정된 변수의 스코프는 `let`의 본문이라는 것을 알 수 있어. 이는 다음을 의미해.

- `let`을 사용하면 변수를 가능한 한 사용될 위치에 가장 가깝게 바인딩할 수 있어. 예를 들어, `x`의 값이 5일 때, 다음 표현식의 값은
    
    Code snippet
    
    ```
    (+ (let ((x 3))
         (+ x (* x 10)))
       x)
    ```
    
    38이야. 여기서 `let`의 본문 안의 `x`는 3이므로 `let` 표현식의 값은 33이야. 반면에, 가장 바깥쪽 `+`의 두 번째 인자인 `x`는 여전히 5야.
    
- 변수 값은 `let` 외부에서 계산돼. 이는 지역 변수에 값을 제공하는 표현식이 지역 변수와 동일한 이름을 가진 변수에 의존할 때 중요해. 예를 들어, `x`의 값이 2일 때, 다음 표현식은
    
    Code snippet
    
    ```
    (let ((x 3)
          (y (+ x 2)))
      (* x y))
    ```
    
    값 12를 가질 거야. 왜냐하면 `let`의 본문 안에서 `x`는 3이 되고 `y`는 4(바깥쪽 `x` 더하기 2)가 될 것이기 때문이야.
    

때로는 내부 정의를 사용하여 `let`과 동일한 효과를 얻을 수 있어. 예를 들어, 위의 `f` 프로시저를 다음과 같이 정의할 수 있었어.

Code snippet

```
(define (f x y)
  (define a
    (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))
```

그러나 우리는 이런 상황에서는 `let`을 사용하고, 내부 `define`은 내부 프로시저에만 사용하는 것을 선호해.

**연습문제 1.34:** 다음 프로시저를 정의했다고 가정해보자.

Code snippet

```
(define (f g) (g 2))
```

그러면 다음과 같을 거야.

Code snippet

```
(f square)
4

(f (lambda (z) (* z (+ z 1))))
6
```

만약 우리가 (일부러) 인터프리터에게 `(f f)` 조합을 평가하도록 요청하면 어떻게 될까? 설명해봐.

### 1.3.3 프로시저를 일반적인 방법으로 (Procedures as General Methods)

우리는 1.1.4에서 복합 프로시저를 숫자 연산의 패턴을 특정 숫자에 구애받지 않고 추상화하는 메커니즘으로 도입했어. 1.3.1의 `integral` 프로시저와 같은 고차 프로시저를 통해, 우리는 더 강력한 종류의 추상화를 보기 시작했어. 바로 특정 함수에 구애받지 않고 일반적인 계산 방법을 표현하는 데 사용되는 프로시저들이지. 이 섹션에서는 두 가지 더 정교한 예시를 다룰 거야. 함수들의 근과 고정점을 찾는 일반적인 방법과 이 방법들을 프로시저로 직접 표현하는 방법을 보여줄 거야.

#### 반분법으로 방정식의 근 찾기 (Finding roots of equations by the half-interval method)

'반분법(half-interval method)'은 연속 함수 f에 대한 방정식 f(x)=0의 근을 찾는 간단하지만 강력한 기술이야. 아이디어는, $f(a) < 0 < f(b)$인 점 a와 b가 주어지면 f는 a와 b 사이에 적어도 하나의 근을 가져야 한다는 거야. 근을 찾기 위해, x를 a와 b의 평균으로 잡고 $f(x)$를 계산해. 만약 f(x)0이면, f는 a와 x 사이에 근을 가져야 해. 만약 $f(x) < 0$이면, f는 x와 b 사이에 근을 가져야 하고. 이런 식으로 계속하면, f가 근을 가져야 하는 점점 더 작은 구간을 식별할 수 있어. 구간이 충분히 작아지는 지점에 도달하면 과정이 멈춰. 불확실성 구간이 과정의 각 단계에서 절반으로 줄어들기 때문에 필요한 단계 수는 $\Theta(\log(L / T))$로 증가하는데, 여기서 L은 원래 구간의 길이이고 T는 허용 오차(즉, "충분히 작다"고 간주할 구간의 크기)야. 이 전략을 구현하는 프로시저는 다음과 같아.

Code snippet

```
(define (search f neg-point pos-point)
  (let ((midpoint
         (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond
           ((positive? test-value)
            (search f neg-point midpoint))
           ((negative? test-value)
            (search f midpoint pos-point))
           (else midpoint))))))
```

우리는 처음에 함수 f와 함께 그 값이 음수와 양수인 점들이 주어진다고 가정해. 먼저 주어진 두 점의 중간점을 계산해. 다음으로 주어진 구간이 충분히 작은지 확인하고, 그렇다면 단순히 중간점을 답으로 반환해. 그렇지 않으면, 중간점에서 f의 값을 테스트 값으로 계산해. 테스트 값이 양수이면 원래 음수점에서 중간점까지의 새로운 구간으로 과정을 계속해. 테스트 값이 음수이면 중간점에서 양수점까지의 구간으로 계속해. 마지막으로, 테스트 값이 0일 가능성이 있는데, 이 경우 중간점 자체가 우리가 찾고 있는 근이야.

끝점이 "충분히 가까운지" 테스트하기 위해 1.1.7에서 제곱근을 계산하는 데 사용된 것과 유사한 프로시저를 사용할 수 있어.

Code snippet

```
(define (close-enough? x y)
  (< (abs (- x y)) 0.001))
```

`search`는 직접 사용하기에 불편해. 왜냐하면 실수로 f의 값이 필요한 부호를 갖지 않는 점을 주게 될 수 있고, 이 경우 잘못된 답을 얻게 되거든. 대신 우리는 `search`를 다음 프로시저를 통해 사용할 거야. 이 프로시저는 끝점 중 어느 것이 음수 함수 값을 가지고 어느 것이 양수 값을 가지는지 확인하고, 그에 따라 `search` 프로시저를 호출해. 만약 함수가 주어진 두 점에서 같은 부호를 가지면 반분법을 사용할 수 없으며, 이 경우 프로시저는 오류를 알릴 거야.

Code snippet

```
(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value)
                (positive? b-value))
           (search f a b))
          ((and (negative? b-value)
                (positive? a-value))
           (search f b a))
          (else
           (error "Values are not of
                   opposite sign" a b)))))
```

다음 예시는 반분법을 사용하여 $\sin x = 0$ 의 2와 4 사이의 근으로 $\pi$를 근사하는 거야.

Code snippet

```
(half-interval-method sin 2.0 4.0)
3.14111328125
```

다음은 반분법을 사용하여 방정식 $x^{3} - 2x - 3 = 0$의 1과 2 사이의 근을 찾는 또 다른 예시야.

Code snippet

```
(half-interval-method
 (lambda (x) (- (* x x x) (* 2 x) 3))
 1.0
 2.0)
1.89306640625
```

#### 함수의 고정점 찾기 (Finding fixed points of functions)

숫자 x는 함수 f의 '고정점(fixed point)'이라고 불려. 만약 x가 방정식 $f(x) = x$를 만족한다면 말이지. 일부 함수 f의 경우 초기 추측부터 시작하여 f를 반복적으로 적용함으로써 고정점을 찾을 수 있어.

$${f(x),}\quad{f(f(x)),}\quad{f(f(f(x))),}\quad{\ldots,}$$

값이 크게 변하지 않을 때까지 말이야. 이 아이디어를 사용하여 함수와 초기 추측을 입력으로 받아 함수의 고정점에 대한 근사치를 생성하는 `fixed-point` 프로시저를 고안할 수 있어. 두 연속 값의 차이가 미리 정해진 허용 오차보다 작아질 때까지 함수를 반복적으로 적용하는 거야.

Code snippet

```
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
```

예를 들어, 이 방법을 사용하여 코사인 함수의 고정점을 근사할 수 있어. 초기 근사치로 1부터 시작하는 거지.

Code snippet

```
(fixed-point cos 1.0)
.7390822985224023
```

마찬가지로, $y = \sin y + \cos y$ 방정식의 해를 찾을 수 있어.

Code snippet

```
(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)
1.2587315962971173
```

고정점 과정은 1.1.7에서 제곱근을 찾는 데 사용했던 과정과 비슷해. 둘 다 결과가 어떤 기준을 만족할 때까지 추측을 반복적으로 개선하는 아이디어에 기반하고 있지. 사실, 제곱근 계산을 고정점 탐색으로 쉽게 만들 수 있어. 어떤 숫자 x의 제곱근을 계산하려면 $y^{2} = x$를 만족하는 y를 찾아야 해. 이 방정식을 $y = x/y$와 동등한 형태로 바꾸면, 우리는 함수 $y\mapsto x/y$의 고정점을 찾고 있다는 것을 알 수 있어. 따라서 제곱근을 다음과 같이 계산하려고 시도할 수 있지.

Code snippet

```
(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
               1.0))
```

안타깝게도, 이 고정점 탐색은 수렴하지 않아. 초기 추측 $y_{1}$을 생각해 보자. 다음 추측은 $y_{2} = x/y_{1}$ 이고 그 다음 추측은 $y_{3} = {x/y_{2}} = {x/(x/y_{1})} = y_{1}$ 이 돼. 이 결과는 답 주위를 오가며 $y_{1}$과 $y_{2}$ 두 가지 추측이 계속해서 반복되는 무한 루프를 만들어.

이런 진동을 제어하는 한 가지 방법은 추측이 너무 많이 변하지 않도록 하는 거야. 답은 항상 우리의 추측 y와 $x/y$ 사이에 있으므로, y와 $x/y$를 평균내어 $x/y$만큼 y에서 멀지 않은 새로운 추측을 만들 수 있어. 그래서 y 다음의 다음 추측은 $x/y$ 대신 $\frac{1}{2}(y + x/y)$가 되는 거지. 이런 일련의 추측을 만드는 과정은 단순히 $y \mapsto \frac{1}{2}(y + x/y)$의 고정점을 찾는 과정과 같아.

Code snippet

```
(define (sqrt x)
  (fixed-point
   (lambda (y) (average y (/ x y)))
   1.0))
```

(참고: $y = \frac{1}{2}(y + x/y)$는 $y = x/y;$ 방정식의 간단한 변형이야. 이를 유도하려면 방정식의 양쪽에 y를 더하고 2로 나누면 돼.)

이 수정으로 제곱근 프로시저는 작동해. 사실, 정의를 풀어보면 여기서 생성된 제곱근에 대한 근사치 시퀀스는 1.1.7의 원래 제곱근 프로시저가 생성한 것과 정확히 같다는 것을 알 수 있어. 해답에 대한 연속적인 근사치를 평균내는 이 접근 방식은 '평균 감쇠(average damping)'라고 부르는데, 고정점 탐색의 수렴을 종종 돕는 데 사용돼.

**연습문제 1.35:** 황금 비율 $\varphi$ (1.2.2)가 변환 $x\mapsto 1 + 1/x$ 의 고정점임을 보여주고, 이 사실을 사용하여 `fixed-point` 프로시저를 통해 $\varphi$ 를 계산해봐.

**연습문제 1.36:** 1.22번 연습문제에 나온 `newline`과 `display` 기본 기능을 사용하여 `fixed-point`가 생성하는 근사치 시퀀스를 출력하도록 수정해봐. 그런 다음 $x^{x} = 1000$ 방정식의 해를 $x\mapsto \log(1000)/\log(x)$의 고정점을 찾아서 구해봐. (Scheme의 기본 `log` 프로시저를 사용해. 이는 자연 로그를 계산해.) 평균 감쇠를 사용했을 때와 사용하지 않았을 때의 단계 수를 비교해봐. (고정점을 1부터 추측으로 시작할 수 없어. $\log(1) = 0$으로 나누는 오류가 발생하기 때문이야.)

**연습문제 1.37:**

1. 무한 '연분수(continued fraction)'는 다음과 같은 형태의 표현식이야.
    
$$f\, = \,{\frac{N_{1}}{D_{1} + \frac{N_{2}}{D_{2} + \frac{N_{3}}{D_{3} + \ldots}}}.}$$

예를 들어, 모든 $N_i$와 $D_i$가 1과 같은 무한 연분수 확장은 $1/\varphi$를 생성한다는 것을 보여줄 수 있어. 여기서 $\varphi$는 황금 비율이야 (1.2.2에 설명되어 있어). 무한 연분수를 근사하는 한 가지 방법은 주어진 항의 수 이후에 확장을 잘라내는 거야. 이러한 절단(유한 연분수)은 다음과 같은 형태를 가져.

$$\frac{N_{1}}{D_{1} + \frac{N_{2}}{\ddots + \frac{N_{k}}{D_{k}}}}.$$

`n`과 `d`가 연분수 항의 $N_i$와 $D_i$를 반환하는 한 인수의 프로시저라고 가정해봐. `(cont-frac n d k)`를 평가하여 $k$-항 유한 연분수의 값을 계산하는 프로시저 `cont-frac`을 정의해봐. 연속적인 `k` 값에 대해 `(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) k)`를 사용하여 $1/\varphi$를 근사하여 프로시저를 확인해봐. 4자리까지 정확한 근사치를 얻으려면 `k`를 얼마나 크게 만들어야 할까?

2. 만약 네 `cont-frac` 프로시저가 재귀 과정을 생성한다면, 반복 과정을 생성하는 프로시저를 작성해봐. 만약 반복 과정을 생성한다면, 재귀 과정을 생성하는 프로시저를 작성해봐.
    
**연습문제 1.38:** 1737년, 스위스 수학자 레온하르트 오일러는 `De Fractionibus Continuis`라는 회고록을 발표했는데, 여기에는 자연로그의 밑인 $e - 2$에 대한 연분수 확장이 포함되어 있었어. 이 분수에서 $N_{i}$는 모두 1이고, $D_{i}$는 순서대로 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, … 이야. 1.37번 연습문제의 `cont-frac` 프로시저를 사용하여 오일러의 확장을 기반으로 e를 근사하는 프로그램을 작성해봐.

**연습문제 1.39:** 탄젠트 함수의 연분수 표현은 1770년 독일 수학자 J.H. 람베르트에 의해 발표되었어.

$${\tan x}\, = \,{\frac{x}{1 - \frac{x^{2}}{3 - \frac{x^{2}}{5 - \ldots}}}\,,}$$

여기서 x는 라디안 단위야. 람베르트의 공식을 기반으로 탄젠트 함수의 근사치를 계산하는 프로시저 `(tan-cf x k)`를 정의해봐. `k`는 1.37번 연습문제에서처럼 계산할 항의 수를 지정해.

### 1.3.4 반환 값으로서의 프로시저 (Procedures as Returned Values)

위의 예시들은 프로시저를 인자로 전달하는 능력이 우리 프로그래밍 언어의 표현력을 얼마나 크게 향상시키는지 보여줘. 반환 값이 그 자체로 프로시저인 프로시저를 생성함으로써 훨씬 더 많은 표현력을 얻을 수 있어.

이 아이디어를 1.3.3 끝에서 설명한 고정점 예시를 다시 살펴보며 설명할 수 있어. 우리는 $\sqrt{x}$가 함수 $y\mapsto x/y$ 의 고정점이라는 관찰에서 시작하여 제곱근 프로시저의 새로운 버전을 고정점 탐색으로 만들었어. 그리고 나서 근사치를 수렴시키기 위해 평균 감쇠를 사용했지. 평균 감쇠는 그 자체로 유용한 일반적인 기술이야. 즉, 함수 f가 주어졌을 때, x에서의 값이 x와 $f(x)$의 평균과 같은 함수를 고려하는 거야.

평균 감쇠의 아이디어는 다음 프로시저를 통해 표현할 수 있어.

Code snippet

```
(define (average-damp f)
  (lambda (x)
    (average x (f x))))
```

`average-damp`는 프로시저 `f`를 인자로 받고, 그 값으로 프로시저(`lambda`에 의해 생성됨)를 반환하는 프로시저야. 이 프로시저가 숫자 `x`에 적용되면 `x`와 `(f x)`의 평균을 생성해. 예를 들어, `average-damp`를 `square` 프로시저에 적용하면, 어떤 숫자 x에서 그 값이 x와 x2의 평균인 프로시저가 생성돼. 이 결과 프로시저를 10에 적용하면 10과 100의 평균, 즉 55가 반환돼.

Code snippet

```
((average-damp square) 10)
55
```

`average-damp`를 사용하여 제곱근 프로시저를 다음과 같이 재구성할 수 있어.

Code snippet

```
(define (sqrt x)
  (fixed-point
   (average-damp
    (lambda (y) (/ x y)))
   1.0))
```

이 공식화가 방법의 세 가지 아이디어: 고정점 탐색, 평균 감쇠, 함수 ymapstox/y를 명시적으로 드러내는 방식에 주목해. 이 제곱근 방법의 공식화를 1.1.7에 주어진 원래 버전과 비교하는 것이 유익할 거야. 이 프로시저들이 같은 과정을 표현한다는 것을 명심하고, 이 추상화들을 사용하여 과정을 표현할 때 아이디어가 얼마나 더 명확해지는지 주목해봐. 일반적으로 과정을 프로시저로 공식화하는 방법은 여러 가지가 있어. 숙련된 프로그래머는 특히 명확하고, 과정의 유용한 요소들을 다른 응용 프로그램에서 재사용할 수 있는 별개의 엔터티로 노출시키는 프로시저 공식화를 선택하는 방법을 알고 있어. 재사용의 간단한 예로, x의 세제곱근은 함수 $y\mapsto x/y^{2}$ 의 고정점이라는 점에 주목해봐. 따라서 우리는 제곱근 프로시저를 세제곱근을 추출하는 프로시저로 즉시 일반화할 수 있어.

Code snippet

```
(define (cube-root x)
  (fixed-point
   (average-damp
    (lambda (y)
      (/ x (square y))))
   1.0))
```

#### 뉴턴 방법 (Newton’s method)

우리가 1.1.7에서 제곱근 프로시저를 처음 소개했을 때, 이것이 '뉴턴 방법(Newton’s method)'의 특별한 경우라고 언급했어. 만약 $x \mapsto g(x)$가 미분 가능한 함수라면, 방정식 g(x)=0의 해는 함수 $x \mapsto f(x)$의 고정점인데, 여기서 $f(x) = x - \frac{g(x)}{Dg(x)}$이고 $Dg(x)$는 x에서 평가된 g의 도함수야. 뉴턴 방법은 함수 f의 고정점을 찾아서 방정식의 해를 근사하는 위에서 본 고정점 방법을 사용하는 것이야.

많은 함수 g와 x에 대한 충분히 좋은 초기 추측에 대해 뉴턴 방법은 g(x)=0의 해로 매우 빠르게 수렴해.

뉴턴 방법을 프로시저로 구현하려면 먼저 '도함수(derivative)'의 개념을 표현해야 해. 평균 감쇠처럼 '도함수'도 함수를 다른 함수로 변환하는 것이라는 점에 주목해. 예를 들어, 함수 $x\mapsto x^{3}$ 의 도함수는 함수 $x\mapsto 3x^{2}$ 이야. 일반적으로, g가 함수이고 dx가 작은 숫자라면, g의 도함수 Dg는 어떤 숫자 x에서의 값이 (작은 dx의 극한에서) 다음으로 주어지는 함수야.

$$Dg(x)\, = \,{\frac{g(x + dx) - g(x)}{dx}.}$$

따라서 우리는 도함수의 개념을 (예를 들어, dx를 0.00001로 가정하고) 다음 프로시저로 표현할 수 있어.

Code snippet

```
(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))
```

다음 정의와 함께 말이야.

Code snippet

```
(define dx 0.00001)
```

`average-damp`처럼 `deriv`는 프로시저를 인자로 받아 프로시저를 값으로 반환하는 프로시저야. 예를 들어, $x\mapsto x^{3}$ 의 도함수를 5에서 근사하려면 (정확한 값은 75), 다음을 평가할 수 있어.

Code snippet

```
(define (cube x) (* x x x))

((deriv cube) 5)
75.00014999664018
```

`deriv`의 도움으로 뉴턴 방법을 고정점 과정으로 표현할 수 있어.

Code snippet

```
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x)
            ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g)
               guess))
```

`newton-transform` 프로시저는 이 섹션 시작 부분의 공식을 표현하고, `newtons-method`는 이것을 바탕으로 쉽게 정의돼. 이 프로시저는 0을 찾고자 하는 함수를 계산하는 프로시저와 초기 추측을 인자로 받아. 예를 들어, x의 제곱근을 찾으려면 뉴턴 방법을 사용하여 함수 $y\mapsto y^{2} - x$ 의 0을 초기 추측 1부터 시작하여 찾을 수 있어.

이것은 제곱근 프로시저의 또 다른 형태를 제공해.

Code snippet

```
(define (sqrt x)
  (newtons-method
   (lambda (y)
     (- (square y) x))
   1.0))
```

#### 추상화와 일급 프로시저 (Abstractions and first-class procedures)

우리는 제곱근 계산을 더 일반적인 방법의 한 예로 표현하는 두 가지 방법, 즉 고정점 탐색과 뉴턴 방법을 사용하는 것을 보았어. 뉴턴 방법 자체도 고정점 과정으로 표현되었으므로, 우리는 실제로 제곱근을 고정점으로 계산하는 두 가지 방법을 본 셈이야. 각 방법은 함수로 시작하여 함수의 어떤 변환의 고정점을 찾아. 우리는 이 일반적인 아이디어를 프로시저로 표현할 수 있어.

Code snippet

```
(define (fixed-point-of-transform
         g transform guess)
  (fixed-point (transform g) guess))
```

이 매우 일반적인 프로시저는 어떤 함수를 계산하는 프로시저 `g`, `g`를 변환하는 프로시저, 그리고 초기 추측을 인자로 받아. 반환된 결과는 변환된 함수의 고정점이야.

이 추상화를 사용하여 이 섹션의 첫 번째 제곱근 계산( $y\mapsto x/y$ 의 평균 감쇠 버전의 고정점을 찾는 것)을 이 일반적인 방법의 한 예로 다시 캐스팅할 수 있어.

Code snippet

```
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y))
   average-damp
   1.0))
```

마찬가지로, 이 섹션의 두 번째 제곱근 계산($y\mapsto y^{2} - x$의 뉴턴 변환의 고정점을 찾는 뉴턴 방법의 한 예)을 다음과 같이 표현할 수 있어.

Code snippet

```
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x))
   newton-transform
   1.0))
```

우리는 1.3 섹션을 시작하면서 복합 프로시저가 중요한 추상화 메커니즘이라는 점에 주목했어. 이는 계산의 일반적인 방법을 우리 프로그래밍 언어의 명시적인 요소로 표현할 수 있게 해주기 때문이야. 이제 고차 프로시저가 이러한 일반적인 방법을 조작하여 더 많은 추상화를 만드는 방법을 보았지.

프로그래머로서 우리는 프로그램에서 기본 추상화를 식별하고, 그것들을 기반으로 구축하고 일반화하여 더 강력한 추상화를 만들 기회를 포착해야 해. 그렇다고 항상 가능한 한 가장 추상적인 방식으로 프로그램을 작성해야 한다는 의미는 아니야. 숙련된 프로그래머는 자신의 작업에 적절한 추상화 수준을 선택하는 방법을 알고 있어. 하지만 이러한 추상화 개념으로 생각할 수 있는 것이 중요해. 그래야 새로운 맥락에서 그것들을 적용할 준비가 될 수 있거든. 고차 프로시저의 중요성은 이러한 추상화를 우리 프로그래밍 언어의 요소로 명시적으로 나타낼 수 있게 하여 다른 계산 요소들처럼 다룰 수 있다는 점이야.

일반적으로 프로그래밍 언어는 계산 요소를 조작할 수 있는 방식에 제약을 가해. 제약이 가장 적은 요소는 '일급(first-class)' 지위를 가진다고 말해. 일급 요소의 몇 가지 "권리와 특권"은 다음과 같아.

- 변수로 이름 붙일 수 있어.
    
- 프로시저의 인자로 전달될 수 있어.
    
- 프로시저의 결과로 반환될 수 있어.
    
- 데이터 구조에 포함될 수 있어.
    

Lisp은 다른 일반적인 프로그래밍 언어와 달리 프로시저에 완전한 일급 지위를 부여해. 이것은 효율적인 구현에 어려움을 주지만, 그 결과로 얻는 표현력의 증가는 엄청나.

**연습문제 1.40:** `newtons-method` 프로시저와 함께 다음과 같은 형태의 표현식에서 사용할 수 있는 `cubic` 프로시저를 정의해봐.

Code snippet

```
(newtons-method (cubic a b c) 1)
```

이것은 x3+ax2+bx+c 삼차 방정식의 근을 근사하는 데 사용돼.

**연습문제 1.41:** 한 인자를 받는 프로시저를 인자로 받아서 원래 프로시저를 두 번 적용하는 프로시저를 반환하는 `double` 프로시저를 정의해봐. 예를 들어, `inc`가 인수에 1을 더하는 프로시저라면, `(double inc)`는 2를 더하는 프로시저여야 해. 다음은 어떤 값을 반환할까?

Code snippet

```
(((double (double double)) inc) 5)
```

**연습문제 1.42:** f와 g가 두 개의 단일 인자 함수라고 하자. g 이후 f의 '합성(composition)'은 함수 $x\mapsto f(g(x))$로 정의돼. 합성을 구현하는 프로시저 `compose`를 정의해봐. 예를 들어, `inc`가 인수에 1을 더하는 프로시저라면,

Code snippet

```
((compose square inc) 6)
49
```

**연습문제 1.43:** f가 숫자 함수이고 n이 양의 정수라면, 우리는 f의 n번째 반복 적용을 구성할 수 있어. 이것은 x에서 그 값이 $f(f(\ldots(f(x))\ldots))$인 함수로 정의돼. 예를 들어, f가 함수 $x\mapsto x + 1$이라면, f의 n번째 반복 적용은 함수 $x\mapsto x + n$이야. 만약 f가 숫자를 제곱하는 연산이라면, f의 n번째 반복 적용은 인자를 $2^{n}\text{-th}$ 제곱으로 만드는 함수야. f를 계산하는 프로시저와 양의 정수 n을 입력으로 받아서 f의 n번째 반복 적용을 계산하는 프로시저를 반환하는 프로시저를 작성해봐. 네 프로시저는 다음과 같이 사용될 수 있어야 해.

Code snippet

```
((repeated square 2) 5)
625
```

힌트: 1.42번 연습문제의 `compose`를 사용하는 것이 편리할 거야.

**연습문제 1.44:** 함수의 '평활화(smoothing)' 아이디어는 신호 처리에서 중요한 개념이야. f가 함수이고 dx가 작은 숫자라면, f의 평활화된 버전은 점 x에서의 값이 $f(x - dx)$, $f(x)$, 그리고 $f(x + dx)$의 평균인 함수야. 함수 f를 계산하는 프로시저를 입력으로 받아서 평활화된 f를 계산하는 프로시저를 반환하는 `smooth` 프로시저를 작성해봐. 함수를 반복적으로 평활화(즉, 평활화된 함수를 평활화하는 등)하여 'n겹 평활화된 함수'를 얻는 것이 때때로 유용해. 1.43번 연습문제의 `smooth`와 `repeated`를 사용하여 주어진 어떤 함수의 n겹 평활화된 함수를 생성하는 방법을 보여봐.

**연습문제 1.45:** 1.3.3에서 $y\mapsto x/y$의 고정점을 순진하게 찾아 제곱근을 계산하려는 시도는 수렴하지 않으며, 평균 감쇠로 이를 해결할 수 있다는 것을 보았어. 같은 방법이 평균 감쇠된 $y\mapsto x/y^{2}$의 고정점으로 세제곱근을 찾는 데도 작동해. 안타깝게도, 네제곱근에는 이 방법이 작동하지 않아. 즉, $y\mapsto x/y^{3}$에 대한 고정점 탐색을 수렴시키려면 한 번의 평균 감쇠로는 충분하지 않지. 반면에, 두 번 평균 감쇠하면 (즉, $y\mapsto x/y^{3}$의 평균 감쇠의 평균 감쇠를 사용하면) 고정점 탐색이 수렴해. $y\mapsto x/y^{n-1}$의 반복적인 평균 감쇠를 기반으로 하는 고정점 탐색으로 n제곱근을 계산하는 데 몇 번의 평균 감쇠가 필요한지 결정하기 위해 몇 가지 실험을 해봐. 이를 사용하여 `fixed-point`, `average-damp`, 그리고 1.43번 연습문제의 `repeated` 프로시저를 사용하여 n제곱근을 계산하는 간단한 프로시저를 구현해봐. 필요한 산술 연산이 기본으로 제공된다고 가정해.

**연습문제 1.46:** 이 장에서 설명된 여러 수치 방법은 '반복 개선(iterative improvement)'이라는 매우 일반적인 계산 전략의 사례야. 반복 개선은 어떤 것을 계산하기 위해, 답에 대한 초기 추측으로 시작하고, 추측이 충분히 좋은지 테스트하며, 그렇지 않으면 추측을 개선하고 개선된 추측을 새로운 추측으로 사용하여 과정을 계속한다고 말해. 두 프로시저를 인자로 받는 `iterative-improve` 프로시저를 작성해봐: 하나는 추측이 충분히 좋은지 알려주는 방법이고, 다른 하나는 추측을 개선하는 방법이야. `iterative-improve`는 추측을 인자로 받아서 충분히 좋아질 때까지 추측을 계속 개선하는 프로시저를 값으로 반환해야 해. 1.1.7의 `sqrt` 프로시저와 1.3.3의 `fixed-point` 프로시저를 `iterative-improve`를 사용하여 다시 작성해봐.