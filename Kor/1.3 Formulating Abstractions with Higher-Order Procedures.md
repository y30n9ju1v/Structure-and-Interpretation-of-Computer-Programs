우리는 프로시저가 특정 숫자에 독립적인 숫자에 대한 복합 연산을 설명하는 추상화라는 것을 보았습니다. 예를 들어, 우리가

코드 스니펫

```
(define (cube x) (* x x x))
```

라고 할 때, 우리는 특정 숫자의 세제곱에 대해 이야기하는 것이 아니라, 어떤 숫자의 세제곱을 얻기 위한 방법에 대해 이야기하는 것입니다. 물론, 우리는 이 프로시저를 정의하지 않고도 항상 다음과 같은 표현식을 작성할 수 있습니다.

코드 스니펫

```
(* 3 3 3)
(* x x x)
(* y y y)
```

그리고 명시적으로 `cube`를 언급하지 않을 수 있습니다. 이것은 우리를 심각한 불이익에 빠뜨릴 것입니다. 즉, 언어의 기본 연산 (이 경우 곱셈) 수준에서만 작업해야 하며, 더 높은 수준의 연산으로는 작업할 수 없게 됩니다. 우리의 프로그램은 세제곱을 계산할 수 있지만, 우리 언어는 세제곱이라는 개념을 표현할 수 없게 됩니다. 강력한 프로그래밍 언어에 요구해야 할 것 중 하나는 공통 패턴에 이름을 할당하여 추상화를 구축하고, 그 추상화를 직접적으로 사용하여 작업할 수 있는 능력입니다. 프로시저는 이러한 능력을 제공합니다. 이것이 가장 기본적인 프로그래밍 언어를 제외한 모든 언어에 프로시저를 정의하는 메커니즘이 포함되어 있는 이유입니다.

그러나 숫자 처리에서도 매개변수가 숫자여야 하는 프로시저에만 국한된다면 추상화를 생성하는 능력에 심각한 제한을 받게 될 것입니다. 종종 동일한 프로그래밍 패턴이 여러 다른 프로시저와 함께 사용됩니다. 이러한 패턴을 개념으로 표현하려면 인수로 프로시저를 받아들이거나 프로시저를 값으로 반환할 수 있는 프로시저를 구성해야 합니다. 프로시저를 조작하는 프로시저를 _고차 프로시저_라고 합니다. 이 섹션에서는 고차 프로시저가 어떻게 강력한 추상화 메커니즘으로 작동하여 언어의 표현력을 크게 향상시킬 수 있는지 보여줍니다.

## 1.3.1 인수로 사용되는 프로시저

다음 세 가지 프로시저를 살펴보세요. 첫 번째는 `a`부터 `b`까지의 정수 합계를 계산합니다.

코드 스니펫

```
(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))
```

두 번째는 주어진 범위에서 정수의 세제곱 합을 계산합니다.

코드 스니펫

```
(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))
```

세 번째는 pi/8로 수렴하는 (매우 느리게) 다음 일련의 항들의 합계를 계산합니다.^[이 계열은 일반적으로 등가 형태 $\frac{\pi}{4} = {1 - \frac{1}{3} + \frac{1}{5}} - {\frac{1}{7} + \ldots}$으로 작성되며 라이프니츠의 것입니다. [3.5.3](https://www.google.com/search?q=3_002e5.xhtml%23g_t3_002e5_002e3)에서 이것을 일부 멋진 숫자 트릭의 기반으로 사용하는 방법을 볼 것입니다.]

$$\frac{1}{1 \cdot 3} + \frac{1}{5 \cdot 7} + \frac{1}{9 \cdot 11} + {\ldots,}$$

코드 스니펫

```
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))
```

이 세 프로시저는 분명히 공통적인 기본 패턴을 공유합니다. 대부분 동일하며, 프로시저의 이름, 추가할 항을 계산하는 `a`의 함수, 그리고 `a`의 다음 값을 제공하는 함수에서만 다릅니다. 우리는 동일한 템플릿의 슬롯을 채워 각 프로시저를 생성할 수 있습니다.

코드 스니펫

```
(define (⟨name⟩ a b)
  (if (> a b)
      0
      (+ (⟨term⟩ a)
         (⟨name⟩ (⟨next⟩ a) b))))
```

이러한 공통 패턴의 존재는 유용한 추상화가 표면으로 드러나기를 기다리고 있다는 강력한 증거입니다. 실제로 수학자들은 오래 전에 _계열의 합계_라는 추상화를 식별하고, 이 개념을 표현하기 위해 "시그마 표기법", 예를 들어

$${\sum\limits_{n = a}^{b}f(n)}\, = \,{f(a)} + \cdots + {f(b),}$$

을 고안했습니다. 시그마 표기법의 힘은 수학자들이 특정 합계만을 다루는 것이 아니라 합계 개념 자체를 다룰 수 있게 해준다는 점입니다. 예를 들어, 특정 계열에 독립적인 합계에 대한 일반적인 결과를 공식화할 수 있습니다.

마찬가지로, 프로그램 설계자로서 우리는 특정 합계를 계산하는 프로시저뿐만 아니라 합계 개념 자체를 표현하는 프로시저를 작성할 수 있을 만큼 언어가 강력하기를 바랍니다. 위에서 보여준 공통 템플릿을 가져와 "슬롯"을 형식 매개변수로 변환함으로써 절차적 언어로 쉽게 그렇게 할 수 있습니다.

코드 스니펫

```
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
```

`sum`은 하한 `a`와 상한 `b`를 인수로 받고, `term` 및 `next` 프로시저도 인수로 받는다는 점에 유의하세요. 우리는 `sum`을 다른 프로시저와 마찬가지로 사용할 수 있습니다. 예를 들어, `sum-cubes`를 정의하기 위해 (인수를 1씩 증가시키는 `inc` 프로시저와 함께) 사용할 수 있습니다.

코드 스니펫

```
(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))
```

이를 사용하여 1부터 10까지의 정수 세제곱 합을 계산할 수 있습니다.

코드 스니펫

```
(sum-cubes 1 10)
3025
```

항을 계산하는 항등 프로시저의 도움으로 `sum-integers`를 `sum`으로 정의할 수 있습니다.

코드 스니펫

```
(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))
```

그러면 1부터 10까지의 정수를 더할 수 있습니다.

코드 스니펫

```
(sum-integers 1 10)
55
```

`pi-sum`도 같은 방식으로 정의할 수 있습니다.^[`pi-next`와 `pi-term`의 정의를 `pi-sum` 내부에 포함시키기 위해 블록 구조([1.1.8](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e8))를 사용했습니다. 이는 이 프로시저들이 다른 목적으로는 유용하지 않을 가능성이 높기 때문입니다. [1.3.2](https://www.google.com/search?q=%23g_t1_002e3_002e2)에서 이들을 완전히 제거하는 방법을 볼 것입니다.]

코드 스니펫

```
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
```

이 프로시저들을 사용하여 pi의 근사값을 계산할 수 있습니다.

코드 스니펫

```
(* 8 (pi-sum 1 1000))
3.139592655589783
```

`sum`을 사용하면 이를 더 많은 개념을 공식화하는 빌딩 블록으로 사용할 수 있습니다. 예를 들어, 함수 f의 a와 b 사이의 정적분은 작은 dx 값에 대해 다음 공식을 사용하여 수치적으로 근사할 수 있습니다.

$${\int_{a}^{b}\mspace{-5mu} f}\; = \;\left\lbrack \; f\left( a + \frac{dx}{2} \right) \right.\, + \,{f\left( a + dx + \frac{dx}{2} \right)}\, + \,{\left. f\left( a + 2dx + \frac{dx}{2} \right)\, + \,\ldots\; \right\rbrack dx}$$

이를 프로시저로 직접 표현할 수 있습니다.

코드 스니펫

```
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

(integral cube 0 1 0.01)
.24998750000000042

(integral cube 0 1 0.001)
.249999875000001
```

(0과 1 사이의 `cube` 적분 값은 정확히 1/4입니다.)

**연습 1.29:** 심슨의 규칙은 위에 설명된 방법보다 더 정확한 수치 적분 방법입니다. 심슨의 규칙을 사용하면 a와 b 사이의 함수 f의 적분은 다음으로 근사됩니다.

$$\frac{h}{3}(y_{0} + {4y_{1}} + {2y_{2}} + {4y_{3}} + {2y_{4}} + \cdots + {2y_{n - 2}} + {4y_{n - 1} + y_{n}),}$$

여기서 h=(b−a)/n이고 n은 짝수 정수이며 $y_{k} = {f(a + kh)}$입니다. (n을 늘리면 근사의 정확도가 증가합니다.) f, a, b, n을 인수로 취하여 심슨의 규칙을 사용하여 계산된 적분 값을 반환하는 프로시저를 정의하세요. 이 프로시저를 사용하여 0과 1 사이에서 `cube`를 적분하고 (n=100 및 n=1000으로), 결과를 위에 표시된 `integral` 프로시저의 결과와 비교하세요.

**연습 1.30:** 위의 `sum` 프로시저는 선형 재귀를 생성합니다. 이 프로시저는 합계가 반복적으로 수행되도록 다시 작성할 수 있습니다. 다음 정의에서 누락된 표현식을 채워 이 작업을 수행하는 방법을 보여주세요.

코드 스니펫

```
(define (sum term a next b)
  (define (iter a result)
    (if ⟨??⟩
        ⟨??⟩
        (iter ⟨??⟩ ⟨??⟩)))
  (iter ⟨??⟩ ⟨??⟩))
```

**연습 1.31:**

1. `sum` 프로시저는 고차 프로시저로 캡처될 수 있는 수많은 유사한 추상화 중 가장 간단한 것일 뿐입니다.^[ [연습 1.31](https://www.google.com/search?q=%23Exercise-1_002e31)부터 [연습 1.33](https://www.google.com/search?q=%23Exercise-1_002e33)까지의 의도는 많은 겉보기에 다른 연산들을 통합하기 위해 적절한 추상화를 사용하여 얻을 수 있는 표현력을 보여주는 것입니다. 그러나 누적 및 필터링은 우아한 아이디어이지만, 이러한 추상화에 적합한 결합 수단을 제공하는 데이터 구조가 아직 없기 때문에 현재로서는 이를 사용하는 데 다소 제한이 있습니다. [2.2.3](https://www.google.com/search?q=2_002e2.xhtml%23g_t2_002e2_002e3)에서 이러한 아이디어를 다시 다루며, 시퀀스를 인터페이스로 사용하여 필터와 누적기를 결합하여 훨씬 더 강력한 추상화를 구축하는 방법을 보여줄 것입니다. 거기서 이러한 방법들이 프로그램 설계에 대한 강력하고 우아한 접근 방식으로 진정으로 효과를 발휘하는 방법을 볼 것입니다.] 주어진 범위에 걸쳐 함수의 값들의 곱을 반환하는 `product`라는 유사한 프로시저를 작성하세요. `product`를 사용하여 `factorial`을 정의하는 방법을 보여주세요. 또한 `product`를 사용하여 다음 공식을 사용하여 pi의 근사값을 계산하세요.^[이 공식은 17세기 영국 수학자 존 윌리스(John Wallis)가 발견했습니다.]
    

$$\frac{\pi}{4}\, = \,{\frac{2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \cdot \cdots}{3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \cdot \cdots}.}$$

2. `product` 프로시저가 재귀 프로세스를 생성하면 반복 프로세스를 생성하는 프로시저를 작성하세요. 반복 프로세스를 생성하면 재귀 프로세스를 생성하는 프로시저를 작성하세요.
    

**연습 1.32:**

1. `sum`과 `product`([연습 1.31](https://www.google.com/search?q=%23Exercise-1_002e31))가 모두 `accumulate`라는 더욱 일반적인 개념의 특수 사례임을 보이세요. `accumulate`는 일부 일반적인 누적 함수를 사용하여 용어들의 컬렉션을 결합합니다.
    
    코드 스니펫
    
    ```
    (accumulate
     combiner null-value term a next b)
    ```
    
    `accumulate`는 `sum` 및 `product`와 동일한 용어 및 범위 사양과 함께, 현재 용어가 이전 용어들의 누적과 어떻게 결합되어야 하는지를 지정하는 `combiner` 프로시저(두 인수)와 용어가 부족할 때 사용할 기본 값을 지정하는 `null-value`를 인수로 취합니다. `accumulate`를 작성하고 `sum`과 `product`가 모두 `accumulate`에 대한 간단한 호출로 정의될 수 있음을 보이세요.
    
2. `accumulate` 프로시저가 재귀 프로세스를 생성하면 반복 프로세스를 생성하는 프로시저를 작성하세요. 반복 프로세스를 생성하면 재귀 프로세스를 생성하는 프로시저를 작성하세요.
    

**연습 1.33:** 결합할 항에 대한 _필터_ 개념을 도입하여 `accumulate`([연습 1.32](https://www.google.com/search?q=%23Exercise-1_002e32))의 더 일반적인 버전을 얻을 수 있습니다. 즉, 지정된 조건을 만족하는 범위의 값에서 파생된 항만 결합합니다. 결과적인 `filtered-accumulate` 추상화는 accumulate와 동일한 인수를 취하며, 필터를 지정하는 추가적인 단일 인수의 술어를 취합니다. `filtered-accumulate`를 프로시저로 작성하세요. `filtered-accumulate`를 사용하여 다음을 표현하는 방법을 보여주세요.

1. a부터 b까지의 구간에 있는 소수의 제곱의 합(이미 `prime?` 술어를 작성했다고 가정)
    
2. n보다 작고 n과 서로소인 모든 양의 정수(textGCD(i,n)=1인 모든 양의 정수 $i \< n$).
    

## 1.3.2 람다를 사용한 프로시저 구성

[1.3.1](https://www.google.com/search?q=%23g_t1_002e3_002e1)에서 `sum`을 사용하는 경우, `pi-term` 및 `pi-next`와 같은 사소한 프로시저를 정의해야만 고차 프로시저의 인수로 사용할 수 있다는 것이 매우 어색하게 느껴집니다. `pi-next`와 `pi-term`을 정의하는 대신 "입력을 4씩 증가시키는 프로시저"와 "입력에 입력 더하기 2를 곱한 것의 역수를 반환하는 프로시저"를 직접 지정하는 방법이 더 편리할 것입니다. `lambda`라는 특수 형식을 도입하면 프로시저를 생성할 수 있습니다. `lambda`를 사용하면 다음과 같이 원하는 것을 설명할 수 있습니다.

코드 스니펫

```
(lambda (x) (+ x 4))
```

및

코드 스니펫

```
(lambda (x) (/ 1.0 (* x (+ x 2))))
```

그러면 `pi-sum` 프로시저는 보조 프로시저를 정의하지 않고도 다음과 같이 표현할 수 있습니다.

코드 스니펫

```
(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
```

다시 `lambda`를 사용하여, 보조 프로시저 `add-dx`를 정의할 필요 없이 `integral` 프로시저를 작성할 수 있습니다.

코드 스니펫

```
(define (integral f a b dx)
  (* (sum f (+ a (/ dx 2.0))
            (lambda (x) (+ x dx))
            b)
     dx))
```

일반적으로 `lambda`는 `define`과 같은 방식으로 프로시저를 생성하는 데 사용되지만, 프로시저에 대한 이름은 지정되지 않습니다.

코드 스니펫

```
(lambda (⟨formal-parameters⟩) ⟨body⟩)
```

결과 프로시저는 `define`을 사용하여 생성된 프로시저와 마찬가지로 프로시저입니다. 유일한 차이점은 환경에서 어떤 이름과도 연관되지 않는다는 것입니다. 사실,

코드 스니펫

```
(define (plus4 x) (+ x 4))
```

는 다음과 동등합니다.

코드 스니펫

```
(define plus4 (lambda (x) (+ x 4)))
```

`lambda` 표현식은 다음과 같이 읽을 수 있습니다.

코드 스니펫

```
(lambda                     (x)     (+   x     4))
    |                        |       |   |     |
the procedure of an argument x that adds x and 4
```

값을 프로시저로 갖는 다른 표현식과 마찬가지로, 람다 표현식은 다음과 같은 조합에서 연산자로 사용될 수 있습니다.

코드 스니펫

```
((lambda (x y z) (+ x y (square z))) 1 2 3)
12
```

또는 더 일반적으로, 우리가 일반적으로 프로시저 이름을 사용할 수 있는 모든 컨텍스트에서 사용될 수 있습니다.^[Lisp를 배우는 사람들이 `lambda`보다 `make-procedure`와 같이 더 명확한 이름을 사용했다면 더 명확하고 덜 위협적이었을 것입니다. 그러나 이 관례는 확고하게 자리 잡았습니다. 이 표기법은 수학적 논리학자 알론조 처치([Church (1941)](https://www.google.com/search?q=References.xhtml%23Church-_00281941_0029))가 도입한 λ-calculus라는 수학적 형식주의에서 채택되었습니다. 처치는 λ-calculus를 함수 및 함수 적용의 개념을 연구하기 위한 엄격한 기반을 제공하기 위해 개발했습니다. λ-calculus는 프로그래밍 언어의 의미론에 대한 수학적 연구를 위한 기본 도구가 되었습니다.]

### `let`을 사용하여 지역 변수 생성

`lambda`의 또 다른 사용은 지역 변수를 생성하는 것입니다. 우리는 종종 형식 매개변수로 바인딩된 변수 외에 프로시저에 지역 변수가 필요합니다. 예를 들어, 함수 $${f(x,y)}, = ,{x(1 + xy)^{2}} + {y(1 - y)} + {(1 + xy)(1 - y),}$$를 계산하고 싶다고 가정해 봅시다. 이 함수는 다음과 같이도 표현할 수 있습니다.

$$\begin{array}{lll}
a & = & {1 + xy,} \\
{\phantom{(x,y)}b} & = & {1 - y,} \\
{f(x,y)} & = & {{xa^{2}} + {yb} + {ab.}} \\
\end{array}$$

f를 계산하는 프로시저를 작성할 때, x와 y뿐만 아니라 a와 b와 같은 중간 양의 이름을 지역 변수로 포함하고 싶을 것입니다. 이를 달성하는 한 가지 방법은 보조 프로시저를 사용하여 지역 변수를 바인딩하는 것입니다.

코드 스니펫

```
(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))
```

물론 `lambda` 표현식을 사용하여 지역 변수를 바인딩하기 위한 익명 프로시저를 지정할 수 있습니다. 그러면 `f`의 본문은 해당 프로시저에 대한 단일 호출이 됩니다.

코드 스니펫

```
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
```

이러한 구성은 매우 유용하여 `let`이라는 특수 형식이 있어 사용하기가 더 편리합니다. `let`을 사용하면 `f` 프로시저는 다음과 같이 작성될 수 있습니다.

코드 스니펫

```
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
```

`let` 표현식의 일반적인 형태는 다음과 같습니다.

코드 스니펫

```
(let ((⟨var₁⟩ ⟨exp₁⟩)
      (⟨var₂⟩ ⟨exp₂⟩)
      …
      (⟨varₙ⟩ ⟨expₙ⟩))
  ⟨body⟩)
```

이는 다음과 같이 생각할 수 있습니다.

코드 스니펫

```
⟨var₁⟩이 ⟨exp₁⟩ 값을 가지고
⟨var₂⟩이 ⟨exp₂⟩ 값을 가지고
…
⟨varₙ⟩이 ⟨expₙ⟩ 값을 가질 때
⟨body⟩를 실행하라
```

`let` 표현식의 첫 번째 부분은 이름-표현식 쌍의 목록입니다. `let`이 평가될 때, 각 이름은 해당 표현식의 값과 연관됩니다. `let`의 본문은 이러한 이름이 지역 변수로 바인딩된 상태에서 평가됩니다. 이러한 방식은 `let` 표현식이 다음의 대체 구문으로 해석되기 때문에 발생합니다.

코드 스니펫

```
((lambda (⟨var₁⟩ … ⟨varₙ⟩)
   ⟨body⟩)
 ⟨exp₁⟩
 …
 ⟨expₙ⟩)
```

인터프리터에서 지역 변수를 제공하기 위해 새로운 메커니즘이 필요하지 않습니다. `let` 표현식은 기본 `lambda` 적용을 위한 단지 구문 설탕일 뿐입니다.

이 동등성에서 우리는 `let` 표현식으로 지정된 변수의 범위가 `let`의 본문임을 알 수 있습니다. 이는 다음을 의미합니다.

- `Let`은 변수를 가능한 한 사용될 위치에 가깝게 바인딩할 수 있도록 합니다. 예를 들어, `x`의 값이 5인 경우 다음 표현식의 값은
    
    코드 스니펫
    
    ```
    (+ (let ((x 3))
         (+ x (* x 10)))
       x)
    ```
    
    는 38입니다. 여기서 `let`의 본문에 있는 `x`는 3이므로 `let` 표현식의 값은 33입니다. 반면에 가장 바깥쪽 `+`의 두 번째 인수 `x`는 여전히 5입니다.
    
- 변수의 값은 `let` 외부에서 계산됩니다. 이는 지역 변수에 대한 값을 제공하는 표현식이 지역 변수와 동일한 이름을 가진 변수에 의존하는 경우에 중요합니다. 예를 들어, `x`의 값이 2인 경우 다음 표현식은
    
    코드 스니펫
    
    ```
    (let ((x 3)
          (y (+ x 2)))
      (* x y))
    ```
    
    `let`의 본문 내부에서 `x`는 3이 되고 `y`는 4(바깥쪽 `x`에 2를 더한 값)가 되므로 값은 12가 됩니다.
    

때때로 우리는 `let`과 동일한 효과를 얻기 위해 내부 정의를 사용할 수 있습니다. 예를 들어, 위에서 설명한 `f` 프로시저는 다음과 같이 정의할 수 있습니다.

코드 스니펫

```
(define (f x y)
  (define a
    (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))
```

그러나 우리는 이러한 상황에서는 `let`을 사용하고, 내부 `define`은 내부 프로시저에만 사용하는 것을 선호합니다.^[내부 정의가 우리가 의도한 바를 의미하는지 확실히 이해하려면 이 장에서 제시한 것보다 더 정교한 평가 모델이 필요합니다. 그러나 프로시저의 내부 정의에서는 이러한 미묘한 차이가 발생하지 않습니다. 평가에 대해 더 많이 배운 후 [4.1.6](https://www.google.com/search?q=4_002e1.xhtml%23g_t4_002e1_002e6)에서 이 문제로 돌아올 것입니다.]

**연습 1.34:** 다음 프로시저를 정의했다고 가정해 봅시다.

코드 스니펫

```
(define (f g) (g 2))
```

그러면 다음과 같이 됩니다.

코드 스니펫

```
(f square)
4

(f (lambda (z) (* z (+ z 1))))
6
```

(반대로) 인터프리터에게 `(f f)` 조합을 평가하도록 요청하면 어떻게 될까요? 설명하세요.

## 1.3.3 프로시저를 일반적인 방법으로 사용

[1.1.4](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e4)에서 우리는 복합 프로시저를 숫자 연산 패턴을 특정 숫자에 독립적으로 추상화하는 메커니즘으로 소개했습니다. [1.3.1](https://www.google.com/search?q=%23g_t1_002e3_002e1)의 `integral` 프로시저와 같은 고차 프로시저를 통해 우리는 더 강력한 종류의 추상화를 보기 시작했습니다. 즉, 특정 함수와 독립적으로 일반적인 계산 방법을 표현하는 데 사용되는 프로시저입니다. 이 섹션에서는 두 가지 더 정교한 예시(함수의 0점 및 고정점을 찾는 일반적인 방법)를 논의하고 이러한 방법을 프로시저로 직접 표현하는 방법을 보여줍니다.

### 반간격법을 이용한 방정식의 근 찾기

_반간격법_은 연속 함수 f에 대해 방정식 f(x)=0의 근을 찾는 간단하지만 강력한 기술입니다. 아이디어는 $f(a) < 0 < f(b)$와 같은 점 a와 b가 주어지면 f는 a와 b 사이에 적어도 하나의 0점을 가져야 한다는 것입니다. 0점을 찾으려면 x를 a와 b의 평균으로 놓고 $f(x)$를 계산합니다. 만약 f(x)0이면, f는 a와 x 사이에 0점을 가져야 합니다. 만약 $f(x) \< 0$이면, f는 x와 b 사이에 0점을 가져야 합니다. 이런 식으로 계속하면 f가 0점을 가져야 하는 점점 더 작은 간격을 식별할 수 있습니다. 간격이 충분히 작아지는 지점에 도달하면 프로세스가 중지됩니다. 불확실성 간격이 프로세스의 각 단계에서 절반으로 줄어들기 때문에 필요한 단계 수는 $\Theta(\log(L,/, T))$로 증가합니다. 여기서 L은 원래 간격의 길이이고 T는 오차 허용 오차(즉, "충분히 작다"고 간주할 간격의 크기)입니다. 다음은 이 전략을 구현하는 프로시저입니다.

코드 스니펫

```
(define (search f neg-point pos-point)
  (let ((midpoint
         (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond
           ((positive? test-value)
            (search f neg-point midpoint))
           ((negative? test-value)
            (search f midpoint pos-point))
           (else midpoint))))))
```

우리는 처음에 함수 f와 그 값이 음수 및 양수인 점이 주어진다고 가정합니다. 먼저 두 주어진 점의 중간점을 계산합니다. 다음으로 주어진 간격이 충분히 작은지 확인하고, 그렇다면 단순히 중간점을 답으로 반환합니다. 그렇지 않으면 중간점에서 f의 값을 테스트 값으로 계산합니다. 테스트 값이 양수이면 원래 음수점에서 중간점까지의 새로운 간격으로 프로세스를 계속합니다. 테스트 값이 음수이면 중간점에서 양수점까지의 간격으로 계속합니다. 마지막으로 테스트 값이 0일 가능성이 있습니다. 이 경우 중간점 자체가 우리가 찾고 있는 근이 됩니다.

종료점이 "충분히 가까운지" 테스트하려면 [1.1.7](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e7)에서 제곱근을 계산하는 데 사용된 것과 유사한 프로시저를 사용할 수 있습니다.^[우리는 0.001을 계산에서 허용 가능한 오차에 대한 허용 오차를 나타내는 대표적인 "작은" 숫자로 사용했습니다. 실제 계산에 적합한 허용 오차는 해결할 문제와 컴퓨터 및 알고리즘의 한계에 따라 달라집니다. 이는 종종 매우 미묘한 고려 사항이며, 수치 해석가 또는 다른 종류의 마법사의 도움이 필요합니다.]

코드 스니펫

```
(define (close-enough? x y)
  (< (abs (- x y)) 0.001))
```

`search`는 직접 사용하기에 서투릅니다. 왜냐하면 f의 값이 필요한 부호를 갖지 않는 지점을 실수로 주어 잘못된 답을 얻을 수 있기 때문입니다. 대신 우리는 다음 프로시저를 통해 `search`를 사용할 것입니다. 이 프로시저는 어떤 끝점이 음수 함수 값을 가지고 어떤 끝점이 양수 값을 가지는지 확인하고, 그에 따라 `search` 프로시저를 호출합니다. 만약 함수가 두 주어진 지점에서 동일한 부호를 가진다면, 반간격법은 사용될 수 없으며, 이 경우 프로시저는 오류를 알립니다.^[이는 `error`를 사용하여 달성할 수 있으며, `error`는 오류 메시지로 인쇄될 여러 항목을 인수로 취합니다.]

코드 스니펫

```
(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value)
                (positive? b-value))
           (search f a b))
          ((and (negative? b-value)
                (positive? a-value))
           (search f b a))
          (else
           (error "Values are not of
                   opposite sign" a b)))))
```

다음 예제는 반간격법을 사용하여 sinx=0의 2와 4 사이의 근으로 pi를 근사합니다.

코드 스니펫

```
(half-interval-method sin 2.0 4.0)
3.14111328125
```

다음은 반간격법을 사용하여 x3−2x−3=0 방정식의 1과 2 사이의 근을 찾는 또 다른 예입니다.

코드 스니펫

```
(half-interval-method
 (lambda (x) (- (* x x x) (* 2 x) 3))
 1.0
 2.0)
1.89306640625
```

### 함수의 고정점 찾기

숫자 x는 방정식 f(x)=x를 만족하면 함수 f의 _고정점_이라고 불립니다. 일부 함수 f의 경우 초기 추측부터 시작하여 f를 반복적으로 적용하여 고정점을 찾을 수 있습니다.

$${f(x),}\quad{f(f(x)),}\quad{f(f(f(x))),}\quad{\ldots,}$$

값이 크게 변하지 않을 때까지요. 이 아이디어를 사용하여 함수와 초기 추측을 인수로 받아 함수의 고정점 근사값을 생성하는 `fixed-point` 프로시저를 고안할 수 있습니다. 함수를 반복적으로 적용하여 차이가 정해진 허용 오차보다 작은 두 연속적인 값을 찾을 때까지 적용합니다.

코드 스니펫

```
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
```

예를 들어, 우리는 이 방법을 사용하여 코사인 함수의 고정점을 1을 초기 근사값으로 시작하여 근사할 수 있습니다.^[지루한 강의 중에 이렇게 해보세요: 계산기를 라디안 모드로 설정하고 `cos` 버튼을 고정점을 얻을 때까지 반복해서 누르세요.]

코드 스니펫

```
(fixed-point cos 1.0)
.7390822985224023
```

마찬가지로, 우리는 방정식 y=siny+cosy의 해를 찾을 수 있습니다.

코드 스니펫

```
(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)
1.2587315962971173
```

고정점 프로세스는 [1.1.7](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e7)에서 제곱근을 찾는 데 사용한 프로세스를 연상시킵니다. 둘 다 결과가 특정 기준을 만족할 때까지 추측을 반복적으로 개선하는 아이디어에 기반합니다. 실제로 제곱근 계산을 고정점 탐색으로 쉽게 공식화할 수 있습니다. 어떤 숫자 x의 제곱근을 계산하려면 y2=x를 만족하는 y를 찾아야 합니다. 이 방정식을 동등한 형태인 y=x/y로 바꾸면, 우리는 함수 ymapstox/y의 고정점을 찾고 있음을 알 수 있으며, 따라서 제곱근을 다음과 같이 계산해 볼 수 있습니다.^[mapsto (발음은 "맵스 투")는 수학자들이 `lambda`를 쓰는 방식입니다. ymapstox/y는 `(lambda (y) (/ x y))`를 의미합니다. 즉, y에서 값이 x/y인 함수입니다.]

코드 스니펫

```
(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
               1.0))
```

불행히도 이 고정점 탐색은 수렴하지 않습니다. 초기 추측 $y_{1}$을 고려해 봅시다. 다음 추측은 $y_{2} = x/y_{1}$이고 다음 추측은 $y_{3} = {x/y_{2}} = {x/(x/y_{1})} = y_{1}$입니다. 이는 두 추측 $y_{1}$과 $y_{2}$가 해를 중심으로 계속 반복적으로 진동하는 무한 루프를 발생시킵니다.

이러한 진동을 제어하는 한 가지 방법은 추측이 너무 많이 변하는 것을 방지하는 것입니다. 해가 항상 현재 추측 y와 x/y 사이에 있기 때문에, y와 x/y의 평균을 취하여 y만큼 멀지 않은 새로운 추측을 할 수 있습니다. 따라서 y 다음의 다음 추측은 x/y 대신 $\frac{1}{2}(y + x/y)$가 됩니다. 이러한 추측 시퀀스를 만드는 과정은 단순히 $y\mapsto{\frac{1}{2}(y + x/y)}$의 고정점을 찾는 과정입니다.

코드 스니펫

```
(define (sqrt x)
  (fixed-point
   (lambda (y) (average y (/ x y)))
   1.0))
```

(참고: $y = {\frac{1}{2}(y + x/y)}$는 방정식 y=x/y의 간단한 변형입니다. 이를 유도하려면 방정식의 양변에 y를 더하고 2로 나눕니다.)

이러한 수정으로 제곱근 프로시저는 작동합니다. 사실, 정의를 풀어보면 여기에서 생성된 제곱근 근사 시퀀스가 [1.1.7](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e7)의 원래 제곱근 프로시저에서 생성된 시퀀스와 정확히 동일하다는 것을 알 수 있습니다. 이러한 연속적인 근사치를 평균하는 접근 방식, 즉 우리가 _평균 감쇠_라고 부르는 기술은 고정점 탐색의 수렴을 종종 돕습니다.

**연습 1.35:** 황금비 varphi([1.2.2](https://www.google.com/search?q=1_002e2.xhtml%23g_t1_002e2_002e2))가 변환 xmapsto1+1/x의 고정점임을 보이고, 이 사실을 이용하여 `fixed-point` 프로시저를 통해 varphi를 계산하세요.

**연습 1.36:** [연습 1.22](https://www.google.com/search?q=1_002e2.xhtml%23Exercise-1_002e22)에 나와 있는 `newline` 및 `display` 원시형을 사용하여 생성된 근사치 시퀀스를 출력하도록 `fixed-point`를 수정하세요. 그런 다음 xx=1000의 해를 $x\mapsto{\log(1000)/\log(x)}$의 고정점을 찾아 해결하세요. (자연 로그를 계산하는 Scheme의 원시 `log` 프로시저를 사용하세요.) 평균 감쇠 사용 여부에 따른 단계 수를 비교하세요. (참고: log(1)=0으로 인해 0으로 나누게 되므로 `fixed-point`를 1의 추측으로 시작할 수 없습니다.)

**연습 1.37:**

1. 무한 _연분수_는 다음과 같은 형태의 표현식입니다.
    

$$f\, = \,{\frac{N_{1}}{D_{1} + \frac{N_{2}}{D_{2} + \frac{N_{3}}{D_{3} + \ldots}}}.}$$


예를 들어, $N_{i}$와 $D_{i}$가 모두 1인 무한 연분수 전개는 $1/\varphi$를 생성한다는 것을 보일 수 있습니다. 여기서 $\varphi$는 황금비입니다([1.2.2](1_002e2.xhtml#g_t1_002e2_002e2) 참조). 무한 연분수를 근사하는 한 가지 방법은 주어진 항 수 이후에 전개를 자르는 것입니다. 이러한 잘린 형태—소위 **k*-항 유한 연분수*—는 다음과 같은 형태를 가집니다.


$$\frac{N_{1}}{D_{1} + \frac{N_{2}}{\ddots + \frac{N_{k}}{D_{k}}}}.$$


`n`과 `d`가 연분수의 항($i$는 항 인덱스)의 $N_{i}$와 $D_{i}$를 반환하는 단일 인수의 프로시저라고 가정합시다. `(cont-frac n d k)`를 평가하면 $k$-항 유한 연분수의 값을 계산하는 프로시저 `cont-frac`을 정의하세요. 다음을 사용하여 $1/\varphi$를 근사하여 프로시저를 확인하세요.

``` {.scheme}
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
```

연속적인 `k` 값에 대해. 4자리 정확도의 근사값을 얻기 위해 `k`를 얼마나 크게 해야 합니까?

2. `cont-frac` 프로시저가 재귀 프로세스를 생성하면 반복 프로세스를 생성하는 프로시저를 작성하세요. 반복 프로세스를 생성하면 재귀 프로세스를 생성하는 프로시저를 작성하세요.
    

**연습 1.38:** 1737년, 스위스 수학자 레온하르트 오일러는 자연 로그의 밑인 e−2에 대한 연분수 전개가 포함된 De Fractionibus Continuis라는 회고록을 발표했습니다. 이 연분수에서 $N_{i}$는 모두 1이고, $D_{i}$는 차례로 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, … 입니다. [연습 1.37](https://www.google.com/search?q=%23Exercise-1_002e37)의 `cont-frac` 프로시저를 사용하여 오일러의 전개에 기반하여 e를 근사하는 프로그램을 작성하세요.

**연습 1.39:** 탄젠트 함수에 대한 연분수 표현은 1770년에 독일 수학자 J.H. 람베르트에 의해 발표되었습니다.

$${\tan x}\, = \,{\frac{x}{1 - \frac{x^{2}}{3 - \frac{x^{2}}{5 - \ldots}}}\,,}$$

여기서 x는 라디안 단위입니다. 람베르트의 공식에 기반하여 탄젠트 함수를 근사하는 프로시저 `(tan-cf x k)`를 정의하세요. `k`는 [연습 1.37](https://www.google.com/search?q=%23Exercise-1_002e37)에서와 같이 계산할 항의 수를 지정합니다.

## 1.3.4 프로시저를 반환 값으로 사용

위의 예시들은 프로시저를 인수로 전달하는 능력이 프로그래밍 언어의 표현력을 얼마나 크게 향상시키는지 보여줍니다. 반환 값이 프로시저 자체인 프로시저를 생성함으로써 훨씬 더 많은 표현력을 얻을 수 있습니다.

[1.3.3](https://www.google.com/search?q=%23g_t1_002e3_002e3) 끝에서 설명한 고정점 예시를 다시 살펴보면 이 아이디어를 설명할 수 있습니다. 우리는 $\sqrt{x}$가 함수 ymapstox/y의 고정점이라는 관찰에서 시작하여 제곱근 프로시저의 새로운 버전을 고정점 탐색으로 공식화했습니다. 그런 다음 근사값이 수렴하도록 평균 감쇠를 사용했습니다. 평균 감쇠는 그 자체로 유용한 일반적인 기술입니다. 즉, 함수 f가 주어지면, x에서의 값이 x와 $f(x)$의 평균과 같은 함수를 고려합니다.

평균 감쇠 개념은 다음 프로시저를 통해 표현할 수 있습니다.

코드 스니펫

```
(define (average-damp f)
  (lambda (x)
    (average x (f x))))
```

`Average-damp`는 프로시저 `f`를 인수로 받아 프로시저(람다에 의해 생성됨)를 값으로 반환하는 프로시저입니다. 이 반환된 프로시저는 숫자 `x`에 적용될 때 `x`와 `(f x)`의 평균을 생성합니다. 예를 들어, `square` 프로시저에 `average-damp`를 적용하면 어떤 숫자 x에서 x와 $x^{2}$의 평균 값을 갖는 프로시저가 생성됩니다. 이 결과 프로시저를 10에 적용하면 10과 100의 평균인 55가 반환됩니다.^[이것은 연산자 자체가 조합인 조합임을 관찰하십시오. [연습 1.4](https://www.google.com/search?q=1_002e1.xhtml%23Exercise-1_002e4)는 이미 그러한 조합을 형성하는 능력을 보여주었지만, 그것은 단지 장난감 예제였습니다. 여기에서 우리는 고차 프로시저가 반환하는 값으로 얻어지는 프로시저를 적용할 때 그러한 조합에 대한 실제 필요성을 보기 시작합니다.]

코드 스니펫

```
((average-damp square) 10)
55
```

`average-damp`를 사용하여 제곱근 프로시저를 다음과 같이 재구성할 수 있습니다.

코드 스니펫

```
(define (sqrt x)
  (fixed-point
   (average-damp
    (lambda (y) (/ x y)))
   1.0))
```

이 공식화가 방법의 세 가지 아이디어: 고정점 탐색, 평균 감쇠, 그리고 함수 ymapstox/y를 얼마나 명시적으로 나타내는지 주목하십시오. 이 제곱근 방법의 공식화를 [1.1.7](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e7)에 주어진 원래 버전과 비교하는 것은 유익합니다. 이 프로시저들이 동일한 프로세스를 표현한다는 점을 명심하고, 이러한 추상화 측면에서 프로세스를 표현할 때 아이디어가 얼마나 더 명확해지는지 주목하십시오. 일반적으로 프로세스를 프로시저로 공식화하는 방법은 여러 가지가 있습니다. 숙련된 프로그래머는 특히 명확하고, 프로세스의 유용한 요소가 다른 응용 프로그램에서 재사용할 수 있는 별개의 엔터티로 노출되는 절차적 공식화를 선택하는 방법을 알고 있습니다. 재사용의 간단한 예로, x의 세제곱근이 함수 $y\mapsto x/y^{2}$의 고정점이라는 점에 유의하십시오. 따라서 제곱근 프로시저를 즉시 세제곱근을 추출하는 프로시저로 일반화할 수 있습니다.^[더 자세한 일반화는 [연습 1.45](https://www.google.com/search?q=%23Exercise-1_002e45)를 참조하십시오.]

코드 스니펫

```
(define (cube-root x)
  (fixed-point
   (average-damp
    (lambda (y)
      (/ x (square y))))
   1.0))
```

### 뉴턴의 방법

[1.1.7](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e7)에서 제곱근 프로시저를 처음 소개했을 때, 이것이 _뉴턴의 방법_의 특수한 경우라고 언급했습니다. $x\mapsto g(x)$가 미분 가능한 함수라면, 방정식 g(x)=0의 해는 함수 $x\mapsto f(x)$의 고정점이며, 여기서

$${f(x)}\, = \, x - \frac{g(x)}{Dg(x)}$$

이고 $Dg(x)$는 x에서 평가된 g의 미분입니다. 뉴턴의 방법은 위에서 본 고정점 방법을 사용하여 함수 f의 고정점을 찾아 방정식의 해를 근사하는 것입니다.^[초등 미적분 책에서는 보통 뉴턴의 방법을 $x_{n + 1} = x_{n} - {g(x_{n}),/Dg(x_{n})}$이라는 근사 시퀀스로 설명합니다. 프로세스에 대해 이야기하고 고정점의 개념을 사용하면 방법 설명이 단순해집니다.]

많은 함수 g와 충분히 좋은 x의 초기 추측에 대해 뉴턴의 방법은 g(x)=0의 해로 매우 빠르게 수렴합니다.^[뉴턴의 방법이 항상 해로 수렴하는 것은 아니지만, 유리한 경우에는 각 반복이 근사치의 자릿수 정확도를 두 배로 증가시키는 것으로 알려져 있습니다. 이러한 경우 뉴턴의 방법은 반간격법보다 훨씬 빠르게 수렴할 것입니다.]

뉴턴의 방법을 프로시저로 구현하려면 먼저 미분 개념을 표현해야 합니다. "미분"은 평균 감쇠와 마찬가지로 함수를 다른 함수로 변환하는 것임을 주목하십시오. 예를 들어, 함수 $x\mapsto x^{3}$의 미분은 함수 $x\mapsto 3x^{2}$입니다. 일반적으로 g가 함수이고 dx가 작은 숫자라면, g의 미분 Dg는 어떤 숫자 x에서 값이 다음과 같이 주어지는 함수입니다(작은 dx의 극한에서).

$$Dg(x)\, = \,{\frac{g(x + dx) - g(x)}{dx}.}$$

따라서 우리는 미분 개념을 (예를 들어 dx를 0.00001로 사용하여) 다음과 같은 프로시저로 표현할 수 있습니다.

코드 스니펫

```
(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))
```

다음 정의와 함께요.

코드 스니펫

```
(define dx 0.00001)
```

`average-damp`와 마찬가지로 `deriv`는 프로시저를 인수로 받아 프로시저를 값으로 반환하는 프로시저입니다. 예를 들어, $x\mapsto x^{3}$의 5에서의 미분(정확한 값은 75)을 근사하려면 다음을 평가할 수 있습니다.

코드 스니펫

```
(define (cube x) (* x x x))

((deriv cube) 5)
75.00014999664018
```

`deriv`의 도움으로 뉴턴의 방법을 고정점 프로세스로 표현할 수 있습니다.

코드 스니펫

```
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x)
            ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g)
               guess))
```

`newton-transform` 프로시저는 이 섹션 시작 부분의 공식을 표현하고, `newtons-method`는 이를 기반으로 쉽게 정의됩니다. 이 프로시저는 0을 찾고 싶은 함수를 계산하는 프로시저와 초기 추측을 인수로 받습니다. 예를 들어, x의 제곱근을 찾으려면 뉴턴의 방법을 사용하여 ymapstoy2−x 함수의 0을 1을 초기 추측으로 시작하여 찾을 수 있습니다.^[제곱근을 찾는 경우 뉴턴의 방법은 어떤 시작 지점에서든 올바른 해로 빠르게 수렴합니다.]

이는 제곱근 프로시저의 또 다른 형태를 제공합니다.

코드 스니펫

```
(define (sqrt x)
  (newtons-method
   (lambda (y)
     (- (square y) x))
   1.0))
```

### 추상화 및 1급 프로시저

우리는 제곱근 계산을 두 가지 일반적인 방법의 인스턴스로 표현하는 두 가지 방법을 보았습니다. 하나는 고정점 탐색으로, 다른 하나는 뉴턴의 방법을 사용했습니다. 뉴턴의 방법 자체가 고정점 프로세스로 표현되었기 때문에, 우리는 사실 두 가지 방식으로 제곱근을 고정점으로 계산하는 방법을 보았습니다. 각 방법은 함수로 시작하여 함수의 어떤 변환의 고정점을 찾습니다. 우리는 이 일반적인 아이디어 자체를 프로시저로 표현할 수 있습니다.

코드 스니펫

```
(define (fixed-point-of-transform
         g transform guess)
  (fixed-point (transform g) guess))
```

이 매우 일반적인 프로시저는 함수를 계산하는 프로시저 `g`, `g`를 변환하는 프로시저, 그리고 초기 추측을 인수로 받습니다. 반환된 결과는 변환된 함수의 고정점입니다.

이 추상화를 사용하여 이 섹션의 첫 번째 제곱근 계산( ymapstox/y의 평균 감쇠된 버전의 고정점을 찾는 경우)을 이 일반적인 방법의 인스턴스로 재구성할 수 있습니다.

코드 스니펫

```
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y))
   average-damp
   1.0))
```

마찬가지로, 이 섹션의 두 번째 제곱근 계산(ymapstoy2−x의 뉴턴 변환의 고정점을 찾는 뉴턴 방법의 인스턴스)을 다음과 같이 표현할 수 있습니다.

코드 스니펫

```
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x))
   newton-transform
   1.0))
```

우리는 [1.3](https://www.google.com/search?q=%23g_t1_002e3) 섹션을 복합 프로시저가 프로그래밍 언어에서 일반적인 계산 방법을 명시적인 요소로 표현할 수 있도록 하는 중요한 추상화 메커니즘이라는 관찰로 시작했습니다. 이제 우리는 고차 프로시저가 이러한 일반적인 방법을 조작하여 더 많은 추상화를 생성하는 방법을 보았습니다.

프로그래머는 프로그램에서 기본 추상화를 식별하고 이를 기반으로 더 강력한 추상화를 생성하고 일반화할 기회를 항상 주시해야 합니다. 그렇다고 항상 가능한 한 가장 추상적인 방식으로 프로그램을 작성해야 한다는 의미는 아닙니다. 숙련된 프로그래머는 작업에 적합한 추상화 수준을 선택하는 방법을 알고 있습니다. 그러나 이러한 추상화 측면에서 생각할 수 있는 것이 중요합니다. 그래야 새로운 컨텍스트에서 이를 적용할 준비를 할 수 있습니다. 고차 프로시저의 중요성은 이러한 추상화를 프로그래밍 언어에서 명시적으로 요소로 나타낼 수 있도록 하여 다른 계산 요소와 마찬가지로 처리할 수 있도록 한다는 점입니다.

일반적으로 프로그래밍 언어는 계산 요소를 조작할 수 있는 방식에 제한을 가합니다. 제한이 가장 적은 요소는 _일급_ 지위를 가진다고 합니다. 일급 요소의 "권리와 특권" 중 일부는 다음과 같습니다.^[프로그래밍 언어 요소의 일급 지위 개념은 영국 컴퓨터 과학자 크리스토퍼 스트래치(Christopher Strachey, 1916-1975)에 의해 제안되었습니다.]

- 변수로 이름을 지정할 수 있습니다.
    
- 프로시저에 인수로 전달될 수 있습니다.
    
- 프로시저의 결과로 반환될 수 있습니다.
    
- 데이터 구조에 포함될 수 있습니다.^[이는 [2장](https://www.google.com/search?q=Chapter-2.xhtml%23Chapter-2)에서 데이터 구조를 소개한 후에 예시를 볼 것입니다.]
    

다른 일반적인 프로그래밍 언어와 달리 Lisp는 프로시저에 완전한 일급 지위를 부여합니다. 이는 효율적인 구현에 어려움을 주지만, 그 결과 얻어지는 표현력의 이점은 엄청납니다.^[일급 프로시저의 주요 구현 비용은 프로시저가 값으로 반환되도록 허용하면 프로시저가 실행되지 않는 동안에도 프로시저의 자유 변수에 대한 저장 공간을 예약해야 한다는 것입니다. [4.1](https://www.google.com/search?q=4_002e1.xhtml%23g_t4_002e1)에서 학습할 Scheme 구현에서는 이러한 변수가 프로시저의 환경에 저장됩니다.]

**연습 1.40:** 다음과 같은 형태의 표현식에서 `newtons-method` 프로시저와 함께 사용될 수 있는 `cubic` 프로시저를 정의하여 $x^{3} + ax^{2} + bx + c$ 삼차 함수의 근을 근사하세요.

코드 스니펫

```
(newtons-method (cubic a b c) 1)
```

**연습 1.41:** 한 인수의 프로시저를 인수로 받아 원래 프로시저를 두 번 적용하는 프로시저를 반환하는 `double` 프로시저를 정의하세요. 예를 들어, `inc`가 인수에 1을 더하는 프로시저라면, `(double inc)`는 2를 더하는 프로시저여야 합니다. 다음은 어떤 값을 반환합니까?

코드 스니펫

```
(((double (double double)) inc) 5)
```

**연습 1.42:** f와 g가 두 개의 단일 인수 함수라고 합시다. f와 g의 _합성_은 $x\mapsto f(g(x))$로 정의되는 함수입니다. 합성을 구현하는 `compose` 프로시저를 정의하세요. 예를 들어, `inc`가 인수에 1을 더하는 프로시저라면,

코드 스니펫

```
((compose square inc) 6)
49
```

**연습 1.43:** f가 수치 함수이고 n이 양의 정수라면, f의 n번째 반복 적용을 구성할 수 있습니다. 이는 x에서의 값이 $f(f(\ldots(f(x))\ldots))$인 함수로 정의됩니다. 예를 들어, f가 xmapstox+1 함수라면, f의 n번째 반복 적용은 xmapstox+n 함수입니다. f가 숫자를 제곱하는 연산이라면, f의 n번째 반복 적용은 인수를 $2^{n}$제곱으로 올리는 함수입니다. f를 계산하는 프로시저와 양의 정수 n을 인수로 받아 f의 n번째 반복 적용을 계산하는 프로시저를 반환하는 프로시저를 작성하세요. 당신의 프로시저는 다음과 같이 사용될 수 있어야 합니다.

코드 스니펫

```
((repeated square 2) 5)
625
```

힌트: [연습 1.42](https://www.google.com/search?q=%23Exercise-1_002e42)의 `compose`를 사용하는 것이 편리할 수 있습니다.

**연습 1.44:** 함수의 _평활화(smoothing)_ 아이디어는 신호 처리에서 중요한 개념입니다. f가 함수이고 dx가 작은 숫자라면, f의 평활화된 버전은 x 지점에서의 값이 f(x−dx), f(x), $f(x + dx)$의 평균인 함수입니다. f를 계산하는 프로시저를 인수로 받아 평활화된 f를 계산하는 프로시저를 반환하는 `smooth` 프로시저를 작성하세요. 때로는 함수를 반복적으로 평활화(즉, 평활화된 함수를 다시 평활화하는 등)하여 *_n_-겹 평활화된 함수*를 얻는 것이 유용합니다. [연습 1.43](https://www.google.com/search?q=%23Exercise-1_002e43)의 `smooth`와 `repeated`를 사용하여 주어진 함수의 n-겹 평활화된 함수를 생성하는 방법을 보여주세요.

**연습 1.45:** [1.3.3](https://www.google.com/search?q=%23g_t1_002e3_002e3)에서 ymapstox/y의 고정점을 순진하게 찾으려고 하면 제곱근을 계산하는 것이 수렴하지 않고, 이를 평균 감쇠로 해결할 수 있음을 보았습니다. 같은 방법이 평균 감쇠된 $y\mapsto x/y^{2}$의 고정점으로 세제곱근을 찾는 데에도 작동합니다. 불행히도 이 과정은 네제곱근에는 작동하지 않습니다. $y\mapsto x/y^{3}$에 대한 고정점 탐색을 수렴시키려면 단일 평균 감쇠로는 충분하지 않습니다. 반면에, 두 번 평균 감쇠하면 (즉, $y\mapsto x/y^{3}$의 평균 감쇠의 평균 감쇠를 사용하면) 고정점 탐색이 수렴합니다. n제곱근을 반복적인 평균 감쇠된 $y\mapsto x/y^{\mspace{2mu} n - 1}$를 기반으로 하는 고정점 탐색으로 계산하는 데 몇 번의 평균 감쇠가 필요한지 실험하여 확인하세요. 이를 사용하여 `fixed-point`, `average-damp`, 그리고 [연습 1.43](https://www.google.com/search?q=%23Exercise-1_002e43)의 `repeated` 프로시저를 사용하여 n제곱근을 계산하는 간단한 프로시저를 구현하세요. 필요한 모든 산술 연산이 원시형으로 제공된다고 가정하세요.

**연습 1.46:** 이 장에서 설명된 여러 수치 방법은 _반복 개선_이라고 하는 매우 일반적인 계산 전략의 사례입니다. 반복 개선은 어떤 것을 계산하기 위해, 해에 대한 초기 추측으로 시작하고, 추측이 충분히 좋은지 테스트하고, 그렇지 않으면 추측을 개선하고 개선된 추측을 새로운 추측으로 사용하여 프로세스를 계속한다는 것을 말합니다. 두 개의 프로시저를 인수로 받는 `iterative-improve` 프로시저를 작성하세요. 하나는 추측이 충분히 좋은지 판단하는 방법이고, 다른 하나는 추측을 개선하는 방법입니다. `Iterative-improve`는 추측을 인수로 받아 추측이 충분히 좋아질 때까지 계속 개선하는 프로시저를 값으로 반환해야 합니다. [1.1.7](https://www.google.com/search?q=1_002e1.xhtml%23g_t1_002e1_002e7)의 `sqrt` 프로시저와 [1.3.3](https://www.google.com/search?q=%23g_t1_002e3_002e3)의 `fixed-point` 프로시저를 `iterative-improve`를 사용하여 다시 작성하세요.