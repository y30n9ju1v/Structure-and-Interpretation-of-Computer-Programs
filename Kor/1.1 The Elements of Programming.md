강력한 프로그래밍 언어는 단순히 컴퓨터에 작업을 지시하는 수단 이상입니다. 언어는 또한 프로세스에 대한 아이디어를 구성하는 프레임워크 역할을 합니다. 따라서 언어를 설명할 때, 언어가 단순한 아이디어를 결합하여 더 복잡한 아이디어를 형성하는 수단에 특별한 주의를 기울여야 합니다. 모든 강력한 언어에는 이를 달성하기 위한 세 가지 메커니즘이 있습니다:

- **기본 표현식**: 언어가 다루는 가장 단순한 엔티티를 나타냅니다.
    
- **결합 수단**: 단순한 요소로부터 복합 요소를 구축하는 방법입니다.
    
- **추상화 수단**: 복합 요소를 이름 짓고 단위로 조작하는 방법입니다.
    

프로그래밍에서 우리는 두 가지 종류의 요소를 다룹니다: 프로시저와 데이터. (나중에 이것들이 실제로는 그렇게 다르지 않다는 것을 발견할 것입니다.) 비공식적으로, 데이터는 우리가 조작하고 싶은 "재료"이며, 프로시저는 데이터를 조작하는 규칙에 대한 설명입니다. 따라서 모든 강력한 프로그래밍 언어는 기본 데이터와 기본 프로시저를 설명할 수 있어야 하며, 프로시저와 데이터를 결합하고 추상화하는 방법을 가지고 있어야 합니다.

이 장에서는 단순한 숫자 데이터만 다룰 것이므로, 프로시저를 구축하는 규칙에 집중할 수 있습니다.^[숫자를 "단순한 데이터"로 특징 짓는 것은 뻔뻔한 허세입니다. 사실, 숫자를 다루는 것은 모든 프로그래밍 언어에서 가장 까다롭고 혼란스러운 측면 중 하나입니다. 관련된 일반적인 문제는 다음과 같습니다: 일부 컴퓨터 시스템은 2와 같은 _정수_를 2.71과 같은 _실수_와 구별합니다. 실수 2.00은 정수 2와 다릅니까? 정수에 사용되는 산술 연산은 실수에 사용되는 연산과 동일합니까? 6을 2로 나누면 3이 됩니까, 아니면 3.0이 됩니까? 얼마나 큰 숫자를 나타낼 수 있습니까? 몇 자리의 정확도를 나타낼 수 있습니까? 정수의 범위가 실수의 범위와 동일합니까? 물론 이러한 질문 외에도 반올림 및 절단 오류와 관련된 문제들, 즉 수치 해석학 전체가 있습니다. 이 책의 초점은 대규모 프로그램 설계에 있지 수치 기법에 있지 않으므로, 이러한 문제들을 무시할 것입니다. 이 장의 수치 예제는 비정수 연산에서 제한된 수의 소수 자릿수 정확도를 보존할 때 관찰되는 일반적인 반올림 동작을 보여줄 것입니다.] 나중에 장에서는 동일한 규칙을 사용하여 복합 데이터를 조작하는 프로시저를 구축할 수 있음을 볼 것입니다.

## 1.1.1 표현식

프로그래밍을 시작하는 쉬운 방법 중 하나는 Lisp의 Scheme 방언용 인터프리터와 몇 가지 일반적인 상호 작용을 살펴보는 것입니다. 컴퓨터 터미널에 앉아 있다고 상상해 봅시다. _표현식_을 입력하면 인터프리터는 해당 표현식을 _평가_한 결과를 표시합니다.

입력할 수 있는 기본 표현식 중 하나는 숫자입니다. (더 정확하게는, 입력하는 표현식은 10진수로 숫자를 나타내는 숫자입니다.) Lisp에 숫자를 제시하면

코드 스니펫

```
486
```

인터프리터는 다음을 출력하여 응답합니다.^[이 책 전체에서 사용자가 입력한 입력과 인터프리터가 출력한 응답을 구별하고자 할 때 후자를 이탤릭체로 표시합니다.]

코드 스니펫

```
486
```

숫자를 나타내는 표현식은 기본 프로시저(예: `+` 또는 `*`)를 나타내는 표현식과 결합하여 해당 숫자에 대한 프로시저 적용을 나타내는 복합 표현식을 형성할 수 있습니다. 예를 들어:

코드 스니펫

```
(+ 137 349)
486

(- 1000 334)
666

(* 5 99)
495

(/ 10 5)
2

(+ 2.7 10)
12.7
```

프로시저 적용을 나타내기 위해 괄호 안에 표현식 목록을 구분하여 형성된 이러한 표현식을 _조합_이라고 합니다. 목록의 가장 왼쪽 요소를 _연산자_라고 하고 다른 요소를 _피연산자_라고 합니다. 조합의 값은 연산자가 지정한 프로시저를 피연산자의 값인 _인수_에 적용하여 얻습니다.

연산자를 피연산자의 왼쪽에 배치하는 관습은 _전위 표기법_으로 알려져 있으며, 일반적인 수학적 관습에서 크게 벗어나기 때문에 처음에는 다소 혼란스러울 수 있습니다. 그러나 전위 표기법은 몇 가지 장점이 있습니다. 그중 하나는 다음 예제와 같이 임의의 수의 인수를 취할 수 있는 프로시저를 수용할 수 있다는 것입니다.

코드 스니펫

```
(+ 21 35 12 7)
75

(* 25 4 12)
1200
```

연산자가 항상 가장 왼쪽 요소이고 전체 조합이 괄호로 구분되어 있기 때문에 모호함이 발생할 수 없습니다.

전위 표기법의 두 번째 장점은 조합을 _중첩_시킬 수 있도록 간단하게 확장된다는 것입니다. 즉, 요소 자체가 조합인 조합을 가질 수 있습니다.

코드 스니펫

```
(+ (* 3 5) (- 10 6))
19
```

이러한 중첩의 깊이와 Lisp 인터프리터가 평가할 수 있는 표현식의 전체 복잡성에는 (원칙적으로) 제한이 없습니다. 다음처럼 상대적으로 간단한 표현식에도 우리 인간은 혼란스러워합니다.

코드 스니펫

```
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
```

인터프리터는 이를 57로 쉽게 평가할 것입니다. 우리는 이러한 표현식을 다음과 같은 형태로 작성하여 스스로에게 도움을 줄 수 있습니다.

코드 스니펫

```
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

이는 _예쁜 인쇄_라고 알려진 서식 지정 규칙을 따르는데, 각 긴 조합은 피연산자가 수직으로 정렬되도록 작성됩니다. 결과 들여쓰기는 표현식의 구조를 명확하게 보여줍니다.^[Lisp 시스템은 일반적으로 사용자가 표현식 서식을 지정하는 데 도움이 되는 기능을 제공합니다. 특히 유용한 두 가지 기능은 새 줄이 시작될 때마다 적절한 예쁜 인쇄 위치로 자동으로 들여쓰기하는 기능과 오른쪽 괄호가 입력될 때마다 일치하는 왼쪽 괄호를 강조 표시하는 기능입니다.]

복잡한 표현식에서도 인터프리터는 항상 동일한 기본 주기로 작동합니다. 터미널에서 표현식을 읽고, 표현식을 평가하고, 결과를 인쇄합니다. 이러한 작동 방식은 인터프리터가 _읽기-평가-인쇄 루프_로 실행된다고 말할 때 종종 표현됩니다. 특히, 표현식의 값을 명시적으로 인쇄하도록 인터프리터에 지시할 필요가 없다는 점에 유의하십시오.^[Lisp는 모든 표현식이 값을 가진다는 규칙을 따릅니다. 이 규칙은 Lisp의 비효율적인 언어라는 오랜 명성과 함께 Alan Perlis(오스카 와일드를 인용하여)가 "Lisp 프로그래머는 모든 것의 가치를 알지만 아무것도 비용을 모른다"고 농담한 원천입니다.]

## 1.1.2 이름 지정 및 환경

프로그래밍 언어의 중요한 측면은 컴퓨팅 객체를 참조하기 위해 이름을 사용하는 수단을 제공한다는 것입니다. 우리는 이름이 _변수_를 식별하며, 그 변수의 _값_이 객체라고 말합니다.

Lisp의 Scheme 방언에서는 `define`을 사용하여 이름을 지정합니다. `(define size 2)`를 입력하면 인터프리터가 값 2를 이름 `size`와 연결하게 됩니다.^[이 책에서는 정의를 평가하는 데 대한 인터프리터의 응답을 보여주지 않습니다. 이는 구현에 따라 크게 달라지기 때문입니다.] `size`라는 이름이 숫자 2와 연결되면, 우리는 이름을 통해 값 2를 참조할 수 있습니다.

코드 스니펫

```
size
2

(* 5 size)
10
```

다음은 `define` 사용의 추가 예시입니다.

코드 스니펫

```
(define pi 3.14159)
(define radius 10)

(* pi (* radius radius))
314.159

(define circumference (* 2 pi radius))

circumference
62.8318
```

`Define`은 우리 언어의 가장 간단한 추상화 수단입니다. 왜냐하면 이는 위에서 계산된 `circumference`와 같은 복합 연산의 결과를 참조하기 위해 간단한 이름을 사용할 수 있게 해주기 때문입니다. 일반적으로 컴퓨팅 객체는 매우 복잡한 구조를 가질 수 있으며, 매번 사용하려고 할 때마다 그 세부 사항을 기억하고 반복해야 한다면 매우 불편할 것입니다. 실제로 복잡한 프로그램은 점진적으로 복잡성이 증가하는 컴퓨팅 객체를 구축함으로써 구성됩니다. 인터프리터는 이름-객체 연결이 연속적인 상호 작용에서 점진적으로 생성될 수 있기 때문에 이러한 단계별 프로그램 구성을 특히 편리하게 만듭니다. 이 기능은 프로그램의 점진적인 개발 및 테스트를 장려하며, Lisp 프로그램이 일반적으로 많은 수의 상대적으로 간단한 프로시저로 구성되는 주된 이유입니다.

값과 기호를 연결하고 나중에 이를 검색할 수 있다는 것은 인터프리터가 이름-객체 쌍을 추적하는 일종의 메모리를 유지해야 함을 의미한다는 것이 명확해야 합니다. 이 메모리를 _환경_(더 정확하게는 _전역 환경_이라고 합니다. 나중에 계산에 여러 다른 환경이 포함될 수 있음을 알게 될 것이기 때문입니다.)이라고 합니다.^[제3장은 환경의 개념이 인터프리터가 어떻게 작동하는지 이해하고 인터프리터를 구현하는 데 모두 중요하다는 것을 보여줄 것입니다.]

## 1.1.3 조합 평가하기

이 장의 목표 중 하나는 절차적 사고에 대한 문제들을 분리하는 것입니다. 예를 들어, 조합을 평가할 때 인터프리터 자체가 하나의 절차를 따르고 있다는 점을 고려해 봅시다.

> 조합을 평가하려면 다음을 수행합니다.
> 
> > 1. 조합의 하위 표현식을 평가합니다.
> >     
> > 2. 가장 왼쪽 하위 표현식(연산자)의 값인 프로시저를 다른 하위 표현식(피연산자)의 값인 인수에 적용합니다.
> >     

이 간단한 규칙조차도 일반적으로 프로세스에 대한 몇 가지 중요한 점을 보여줍니다. 첫째, 첫 번째 단계는 조합에 대한 평가 프로세스를 완료하기 위해 조합의 각 요소에 대한 평가 프로세스를 먼저 수행해야 한다고 지시합니다. 따라서 평가 규칙은 본질적으로 _재귀적_입니다. 즉, 단계 중 하나로 규칙 자체를 호출해야 합니다.^[평가 규칙이 첫 번째 단계의 일부로 조합의 가장 왼쪽 요소를 평가해야 한다고 말하는 것이 이상하게 들릴 수 있습니다. 이 시점에서는 덧셈이나 곱셈과 같은 내장 원시 프로시저를 나타내는 `+` 또는 `*`와 같은 연산자일 뿐이기 때문입니다. 나중에 연산자 자체가 복합 표현식인 조합으로 작업하는 것이 유용하다는 것을 알게 될 것입니다.]

재귀의 개념이 깊게 중첩된 조합의 경우 다소 복잡한 프로세스로 보일 수 있는 것을 얼마나 간결하게 표현하는 데 사용될 수 있는지 주목하십시오. 예를 들어, 다음을 평가하려면

코드 스니펫

```
(* (+ 2 (* 4 6)) (+ 3 5 7))
```

평가 규칙을 네 가지 다른 조합에 적용해야 합니다.이 프로세스를 그림으로 나타내려면 [그림 1.1](https://www.google.com/search?q=%23Figure-1_002e1)과 같이 조합을 트리 형태로 표현할 수 있습니다. 각 조합은 연산자와 조합의 피연산자에 해당하는 가지를 가진 노드로 표현됩니다. 터미널 노드(즉, 가지가 없는 노드)는 연산자 또는 숫자를 나타냅니다. 트리의 관점에서 평가를 보면, 피연산자의 값이 터미널 노드에서 시작하여 점점 더 높은 수준에서 결합하면서 위쪽으로 퍼지는 것을 상상할 수 있습니다. 일반적으로 재귀는 계층적이고 트리와 같은 객체를 다루는 데 매우 강력한 기술임을 알 수 있습니다. 실제로 "값을 위쪽으로 퍼뜨리는" 평가 규칙의 형태는 _트리 축적_이라고 알려진 일반적인 종류의 프로세스의 예입니다.

![](./images/ch1-Z-G-1.gif)

그림 1.1: 각 하위 조합의 값을 보여주는 트리 표현.

다음으로, 첫 번째 단계의 반복적인 적용은 조합이 아닌 숫자, 내장 연산자 또는 다른 이름과 같은 기본 표현식을 평가해야 하는 지점에 도달한다는 점에 유의하십시오. 우리는 다음과 같이 기본 경우를 처리합니다.

- 숫자의 값은 그들이 이름 짓는 숫자입니다.
    
- 내장 연산자의 값은 해당 작업을 수행하는 기계어 명령 시퀀스입니다.
    
- 다른 이름의 값은 환경에서 해당 이름과 연결된 객체입니다.
    

두 번째 규칙은 `+` 및 `*`와 같은 기호도 전역 환경에 포함되어 "값"인 기계어 명령 시퀀스와 연결된다고 규정함으로써 세 번째 규칙의 특별한 경우로 간주될 수 있습니다. 중요한 점은 표현식의 기호 의미를 결정하는 데 있어 환경의 역할입니다. Lisp와 같은 상호 작용 언어에서는 기호 `x`(또는 `+` 기호)에 대한 의미를 제공하는 환경에 대한 정보를 지정하지 않고 `(+ x 1)`과 같은 표현식의 값에 대해 이야기하는 것은 무의미합니다. [제3장](https://www.google.com/search?q=Chapter-3.xhtml%23Chapter-3)에서 보겠지만, 평가가 일어나는 맥락을 제공하는 환경의 일반적인 개념은 프로그램 실행을 이해하는 데 중요한 역할을 할 것입니다.

위에 주어진 평가 규칙은 정의를 처리하지 않는다는 점에 유의하십시오. 예를 들어, `(define x 3)`을 평가하는 것은 `define`을 두 인수에 적용하는 것이 아닙니다. 이 중 하나는 `x` 기호의 값이고 다른 하나는 3입니다. 왜냐하면 `define`의 목적은 정확히 `x`를 값과 연결하는 것이기 때문입니다. (즉, `(define x 3)`은 조합이 아닙니다.)

일반 평가 규칙에 대한 이러한 예외를 _특별 형식_이라고 합니다. `Define`은 우리가 지금까지 본 특별 형식의 유일한 예이지만, 곧 다른 특별 형식을 만나게 될 것입니다. 각 특별 형식에는 자체 평가 규칙이 있습니다. 다양한 종류의 표현식(각각 관련 평가 규칙 포함)은 프로그래밍 언어의 구문을 구성합니다. 대부분의 다른 프로그래밍 언어와 비교할 때 Lisp는 매우 간단한 구문을 가지고 있습니다. 즉, 표현식에 대한 평가 규칙은 소수의 특별 형식에 대한 특수 규칙과 함께 간단한 일반 규칙으로 설명될 수 있습니다.^[간단한 대안적인 표면 구조이지만 더 통일된 방식으로 작성될 수 있는 특수 구문 형식은 때때로 피터 랜딘(Peter Landin)이 만든 "구문적 설탕(syntactic sugar)"이라는 용어를 사용하기도 합니다. 다른 언어 사용자들과 비교할 때, Lisp 프로그래머들은 일반적으로 구문 문제에 덜 신경 씁니다. (대조적으로, 파스칼 매뉴얼을 보면 구문 설명에 얼마나 많은 부분이 할애되어 있는지 주목하십시오.) 구문에 대한 이러한 경시는 부분적으로 Lisp의 유연성으로 인해 표면 구문을 쉽게 변경할 수 있기 때문이며, 부분적으로는 많은 "편리한" 구문 구조가 언어를 덜 통일성 있게 만들어 프로그램이 크고 복잡해질 때 오히려 더 많은 문제를 야기한다는 관찰 때문입니다. 앨런 펄리스(Alan Perlis)의 말처럼 "구문적 설탕은 세미콜론 암을 유발한다."]

## 1.1.4 복합 프로시저

우리는 Lisp에서 강력한 프로그래밍 언어에 나타나야 할 몇 가지 요소를 식별했습니다.

- 숫자와 산술 연산은 기본 데이터 및 프로시저입니다.
    
- 조합의 중첩은 연산을 결합하는 수단을 제공합니다.
    
- 값과 이름을 연결하는 정의는 제한된 추상화 수단을 제공합니다.
    

이제 우리는 복합 연산에 이름을 부여하고 단위로 참조할 수 있는 훨씬 더 강력한 추상화 기술인 _프로시저 정의_에 대해 배울 것입니다.

우리는 "제곱하기"라는 아이디어를 표현하는 방법부터 시작합니다. "어떤 것을 제곱하려면, 그 자신과 곱한다"라고 말할 수 있습니다. 이는 우리 언어로 다음과 같이 표현됩니다.

코드 스니펫

```
(define (square x) (* x x))
```

우리는 이것을 다음과 같이 이해할 수 있습니다.

코드 스니펫

```
(define (square x)    (*       x       x))
  |      |      |      |       |       |
 To square something, multiply it by itself.
```

여기에는 `square`라는 이름이 부여된 _복합 프로시저_가 있습니다.이 프로시저는 어떤 것을 그 자신과 곱하는 연산을 나타냅니다. 곱해질 것은 `x`라는 지역 이름이 주어지며, 이는 자연어에서 대명사가 하는 것과 같은 역할을 합니다. 정의를 평가하면 이 복합 프로시저가 생성되고 `square`라는 이름과 연결됩니다.^[여기서 두 가지 다른 연산이 결합되고 있다는 점에 유의하십시오. 즉, 프로시저를 생성하고 `square`라는 이름을 부여합니다. 이 두 가지 개념을 분리할 수 있는 것이 가능하며 중요합니다. 즉, 이름을 부여하지 않고 프로시저를 생성하고, 이미 생성된 프로시저에 이름을 부여할 수 있습니다. [1.3.2](https://www.google.com/search?q=1_002e3.xhtml%23g_t1_002e3_002e2)에서 이를 수행하는 방법을 볼 것입니다.]

프로시저 정의의 일반적인 형식은 다음과 같습니다.

코드 스니펫

```
(define (⟨name⟩ ⟨formal parameters⟩) ⟨body⟩)
```

`<name>`은 환경에서 프로시저 정의와 연결될 기호입니다.^[이 책 전체에서 우리는 실제 사용될 때 채워질 표현식의 "슬롯"을 나타내기 위해 기울임꼴로 된 기호(예: `<name>`)를 사용하여 표현식의 일반 구문을 설명할 것입니다.] `<formal parameters>`는 프로시저의 본문 내에서 해당 프로시저의 인수를 참조하는 데 사용되는 이름입니다. `<body`>`는 형식 매개변수가 프로시저가 적용되는 실제 인수로 대체될 때 프로시저 적용의 값을 산출하는 표현식입니다.^[더 일반적으로, 프로시저의 본문은 표현식의 시퀀스일 수 있습니다. 이 경우 인터프리터는 시퀀스의 각 표현식을 차례로 평가하고 마지막 표현식의 값을 프로시저 적용의 값으로 반환합니다.]` \<name\>`과`

`square`를 정의했으므로 이제 사용할 수 있습니다.

코드 스니펫

```
(square 21)
441

(square (+ 2 5))
49

(square (square 3))
81
```

또한 `square`를 다른 프로시저를 정의하는 빌딩 블록으로 사용할 수 있습니다. 예를 들어, $x^{2} + y^{2}$는 다음과 같이 표현될 수 있습니다.

코드 스니펫

```
(+ (square x) (square y))
```

두 숫자를 인수로 받아 제곱의 합을 생성하는 `sum-of-squares` 프로시저를 쉽게 정의할 수 있습니다.

코드 스니펫

```
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
25
```

이제 `sum-of-squares`를 더 나아가 프로시저를 구성하는 빌딩 블록으로 사용할 수 있습니다.

코드 스니펫

```
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
136
```

복합 프로시저는 기본 프로시저와 정확히 동일한 방식으로 사용됩니다.실제로 위에서 주어진 `sum-of-squares`의 정의를 보더라도 `square`가 `+` 및 `*`처럼 인터프리터에 내장되었는지 또는 복합 프로시저로 정의되었는지 알 수 없습니다.

## 1.1.5 프로시저 적용을 위한 대체 모델

연산자가 복합 프로시저의 이름을 지정하는 조합을 평가하기 위해 인터프리터는 [1.1.3](https://www.google.com/search?q=%23g_t1_002e1_002e3)에서 설명한 기본 프로시저의 이름을 지정하는 조합과 거의 동일한 프로세스를 따릅니다. 즉, 인터프리터는 조합의 요소를 평가하고 (조합의 연산자 값인) 프로시저를 (조합의 피연산자 값인) 인수에 적용합니다.

우리는 인수에 기본 프로시저를 적용하는 메커니즘이 인터프리터에 내장되어 있다고 가정할 수 있습니다.복합 프로시저의 경우 적용 프로세스는 다음과 같습니다.

> 복합 프로시저를 인수에 적용하려면 각 형식 매개변수를 해당 인수로 대체하여 프로시저의 본문을 평가합니다.

이 프로세스를 설명하기 위해 다음 조합을 평가해 봅시다.

코드 스니펫

```
(f 5)
```

여기서 `f`는 [1.1.4](https://www.google.com/search?q=%23g_t1_002e1_002e4)에 정의된 프로시저입니다.먼저 `f`의 본문을 검색합니다.

코드 스니펫

```
(sum-of-squares (+ a 1) (* a 2))
```

그런 다음 형식 매개변수 `a`를 인수 5로 바꿉니다.

코드 스니펫

```
(sum-of-squares (+ 5 1) (* 5 2))
```

따라서 문제는 두 피연산자와 연산자 `sum-of-squares`를 가진 조합의 평가로 귀결됩니다.이 조합을 평가하는 데는 세 가지 하위 문제가 포함됩니다. 적용할 프로시저를 얻기 위해 연산자를 평가해야 하고, 인수를 얻기 위해 피연산자를 평가해야 합니다. 이제 `(+ 5 1)`은 6을 생성하고 `(* 5 2)`는 10을 생성하므로 `sum-of-squares` 프로시저를 6과 10에 적용해야 합니다.이 값들은 `sum-of-squares` 본문의 형식 매개변수 `x`와 `y`로 대체되어 표현식을 다음으로 축소합니다.

코드 스니펫

```
(+ (square 6) (square 10))
```

`square`의 정의를 사용하면 다음으로 축소됩니다.

코드 스니펫

```
(+ (* 6 6) (* 10 10))
```

이는 곱셈에 의해 다음으로 축소됩니다.

코드 스니펫

```
(+ 36 100)
```

그리고 최종적으로 다음이 됩니다.

코드 스니펫

```
136
```

우리가 방금 설명한 프로세스를 _대체 모델_이라고 합니다.이 모델은 이 장의 프로시저와 관련하여 프로시저 적용의 "의미"를 결정하는 모델로 간주될 수 있습니다. 그러나 강조해야 할 두 가지 사항이 있습니다.

- 대체의 목적은 프로시저 적용에 대해 생각하는 데 도움을 주기 위한 것이지, 인터프리터가 실제로 어떻게 작동하는지에 대한 설명을 제공하기 위한 것이 아닙니다.일반적인 인터프리터는 형식 매개변수에 값을 대체하기 위해 프로시저의 텍스트를 조작하여 프로시저 적용을 평가하지 않습니다.실제로 "대체"는 형식 매개변수에 대한 지역 환경을 사용하여 수행됩니다.[제3장](https://www.google.com/search?q=Chapter-3.xhtml%23Chapter-3)과 [제4장](https://www.google.com/search?q=Chapter-4.xhtml%23Chapter-4)에서 인터프리터 구현을 자세히 살펴볼 때 이를 더 자세히 논의할 것입니다.
    
- 이 책 전체에서 우리는 인터프리터가 작동하는 방식에 대한 점진적으로 정교한 모델을 제시할 것이며, [제5장](https://www.google.com/search?q=Chapter-5.xhtml%23Chapter-5)에서 인터프리터와 컴파일러의 완전한 구현으로 절정을 이룰 것입니다.대체 모델은 이러한 모델 중 첫 번째 모델일 뿐입니다. 평가 프로세스에 대해 공식적으로 생각하기 시작하는 방법입니다.일반적으로 과학 및 공학에서 현상을 모델링할 때 우리는 단순화되고 불완전한 모델부터 시작합니다.자세히 살펴볼수록 이러한 단순한 모델은 부적절해지며 더 정교한 모델로 대체되어야 합니다.대체 모델도 예외는 아닙니다.특히 [제3장](https://www.google.com/search?q=Chapter-3.xhtml%23Chapter-3)에서 "가변 데이터"가 있는 프로시저 사용을 다룰 때 대체 모델이 무너지고 더 복잡한 프로시저 적용 모델로 대체되어야 한다는 것을 알게 될 것입니다.^[대체 아이디어의 단순성에도 불구하고 대체 프로세스에 대한 엄격한 수학적 정의를 제공하는 것은 놀랍게도 복잡합니다. 문제는 프로시저의 형식 매개변수에 사용되는 이름과 프로시저가 적용될 수 있는 표현식에 사용되는 (동일할 수도 있는) 이름 사이의 혼동 가능성에서 발생합니다. 실제로 논리 및 프로그래밍 의미론 문헌에서 _대체_에 대한 잘못된 정의의 오랜 역사가 있습니다. 대체에 대한 신중한 논의는 [Stoy 1977](https://www.google.com/search?q=References.xhtml%23Stoy-1977)을 참조하십시오.]
    

### 적용 순서 대 정규 순서

[1.1.3](https://www.google.com/search?q=%23g_t1_002e1_002e3)에 주어진 평가 설명에 따르면, 인터프리터는 먼저 연산자와 피연산자를 평가한 다음 결과 프로시저를 결과 인수에 적용합니다.이는 평가를 수행하는 유일한 방법이 아닙니다. 대안적인 평가 모델은 피연산자의 값이 필요할 때까지 피연산자를 평가하지 않을 것입니다. 대신 피연산자 표현식을 매개변수로 대체하여 기본 연산자만 포함하는 표현식을 얻은 다음 평가를 수행합니다.이 방법을 사용하면 `(f 5)`의 평가는 다음과 같은 확장 순서에 따라 진행됩니다.

코드 스니펫

```
(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1)) 
   (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) 
   (* (* 5 2) (* 5 2)))
```

다음으로 이어지는 축소.

코드 스니펫

```
(+ (* 6 6) 
   (* 10 10))

(+ 36 100)

136
```

이것은 이전 평가 모델과 동일한 답을 제공하지만 프로세스는 다릅니다.특히, `(+ 5 1)`과 `(* 5 2)`의 평가는 `x`가 각각 `(+ 5 1)`과 `(* 5 2)`로 대체된 `(* x x)` 표현식의 축소에 해당하여 여기에서 각각 두 번 수행됩니다.

이 대체 "완전히 확장한 다음 축소" 평가 방법은 _정규 순서 평가_라고 알려져 있습니다.이는 인터프리터가 실제로 사용하는 "인수를 평가한 다음 적용" 방법인 _적용 순서 평가_와 대조됩니다.대체를 사용하여 모델링할 수 있는 프로시저(이 책의 처음 두 장의 모든 프로시저 포함)의 경우 정규 순서 평가와 적용 순서 평가가 동일한 값을 생성한다는 것을 보여줄 수 있습니다.("부적절한" 값의 예는 [연습 문제 1.5](https://www.google.com/search?q=%23Exercise-1_002e5)를 참조하십시오. 여기서 정규 순서 평가와 적용 순서 평가가 동일한 결과를 제공하지 않습니다.)

Lisp는 적용 순서 평가를 사용합니다. 부분적으로는 위에서 `(+ 5 1)` 및 `(* 5 2)`와 같은 표현식의 다중 평가를 피함으로써 얻는 추가 효율성 때문이며, 더 중요하게는 대체로 모델링할 수 있는 프로시저 영역을 벗어날 때 정규 순서 평가가 훨씬 더 복잡해지기 때문입니다.반면에 정규 순서 평가 역시 매우 유용한 도구가 될 수 있으며, [제3장](https://www.google.com/search?q=Chapter-3.xhtml%23Chapter-3)과 [제4장](https://www.google.com/search?q=Chapter-4.xhtml%23Chapter-4)에서 그 의미 중 일부를 탐구할 것입니다.^[제3장에서는 제한된 형태의 정규 순서 평가를 통합하여 겉으로는 "무한"한 데이터 구조를 처리하는 방법인 _스트림 처리_를 소개할 것입니다. [4.2](https://www.google.com/search?q=4_002e2.xhtml%23g_t4_002e2)에서는 Scheme 인터프리터를 수정하여 Scheme의 정규 순서 변형을 생성할 것입니다.]

## 1.1.6 조건식과 서술어

이 시점에서 정의할 수 있는 프로시저 클래스의 표현력은 매우 제한적입니다. 왜냐하면 테스트를 수행하고 테스트 결과에 따라 다른 작업을 수행하는 방법이 없기 때문입니다. 예를 들어, 숫자가 양수, 음수 또는 0인지 테스트하고 규칙에 따라 다른 경우에 다른 작업을 수행하여 숫자의 절댓값을 계산하는 프로시저를 정의할 수 없습니다.

$$\left| x \right|\; = \;\left\{ \begin{array}{lll}
x & {\;\text{if}} & {x > 0,} \\
0 & {\;\text{if}} & {x = 0,} \\
{- x} & {\;\text{if}} & {x < 0.} \\
\end{array} \right.$$

이 구문은 _케이스 분석_이라고 불리며, 이러한 케이스 분석을 표기하기 위한 Lisp의 특별 형식이 있습니다.이는 `cond`("conditional"의 약어)라고 불리며 다음과 같이 사용됩니다.

코드 스니펫

```
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
```

조건식의 일반적인 형식은 다음과 같습니다.

코드 스니펫

```
(cond (⟨p₁⟩ ⟨e₁⟩)
      (⟨p₂⟩ ⟨e₂⟩)
      …
      (⟨pₙ⟩ ⟨eₙ⟩))
```

`cond` 기호 뒤에 괄호로 묶인 표현식 쌍이 옵니다.

코드 스니펫

```
(⟨p⟩ ⟨e⟩)
```

이를 _절_이라고 합니다.각 쌍의 첫 번째 표현식은 _서술어_입니다. 즉, 값이 참 또는 거짓으로 해석되는 표현식입니다.^[“참 또는 거짓으로 해석된다”는 것은 이것을 의미합니다. Scheme에는 `#t`와 `#f` 상수로 표시되는 두 가지 특수한 값이 있습니다. 인터프리터가 서술어의 값을 확인할 때, `#f`를 거짓으로 해석합니다. 다른 모든 값은 참으로 간주됩니다. (따라서 `#t`를 제공하는 것은 논리적으로 불필요하지만 편리합니다.) 이 책에서는 `#t` 및 `#f` 값과 연결된 `true` 및 `false` 이름을 사용할 것입니다.]

조건식은 다음과 같이 평가됩니다.서술어 langlep_1rangle이 먼저 평가됩니다.그 값이 거짓이면 langlep_2rangle가 평가됩니다.langlep_2rangle의 값도 거짓이면 langlep_3rangle이 평가됩니다.이 과정은 값이 참인 서술어를 찾을 때까지 계속되며, 이 경우 인터프리터는 해당 절의 _결과 표현식_ langleerangle의 값을 조건식의 값으로 반환합니다.만약 langleprangle 중 어떤 것도 참이 아닌 것으로 판명되면, `cond`의 값은 정의되지 않습니다.

_서술어_라는 단어는 참 또는 거짓을 반환하는 프로시저뿐만 아니라 참 또는 거짓으로 평가되는 표현식에도 사용됩니다.절댓값 프로시저 `abs`는 기본 서술어 `>`, `<`, 및 `=`을 사용합니다.^[ `Abs`는 또한 단일 피연산자와 함께 사용될 때(예: `(- x)`) 부정을 나타내는 "마이너스" 연산자 `-`를 사용합니다.]이것들은 두 숫자를 인수로 받아 첫 번째 숫자가 두 번째 숫자보다 각각 크거나, 작거나, 같은지 테스트하고 그에 따라 참 또는 거짓을 반환합니다.

절댓값 프로시저를 작성하는 또 다른 방법은 다음과 같습니다.

코드 스니펫

```
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
```

이는 영어로 "만약 x가 0보다 작으면 −x를 반환하고, 그렇지 않으면 x를 반환한다"라고 표현될 수 있습니다.`Else`는 `cond`의 마지막 절에서 langleprangle 대신 사용될 수 있는 특수 기호입니다.이것은 이전 절이 모두 건너뛰어질 때마다 `cond`가 해당 langleerangle의 값을 값으로 반환하게 합니다.사실, 항상 참 값으로 평가되는 어떤 표현식도 여기에서 langleprangle로 사용될 수 있습니다.

절댓값 프로시저를 작성하는 또 다른 방법은 다음과 같습니다.

코드 스니펫

```
(define (abs x)
  (if (< x 0)
      (- x)
      x))
```

이것은 _if_라는 특별한 형식을 사용합니다. _if_는 케이스 분석에 정확히 두 가지 경우가 있을 때 사용할 수 있는 제한된 유형의 조건문입니다.if 표현식의 일반적인 형식은 다음과 같습니다.

코드 스니펫

```
(if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩)
```

`if` 표현식을 평가하기 위해 인터프리터는 먼저 표현식의 `<predicate>` 부분을 평가합니다.`<predicate>`가 참 값으로 평가되면 인터프리터는 `<consequent>`를 평가하고 해당 값을 반환합니다.그렇지 않으면 `<alternative>`를 평가하고 해당 값을 반환합니다.^[ `if`와 `cond` 사이의 사소한 차이점은 각 `cond` 절의 `<e>` 부분이 표현식 시퀀스일 수 있다는 것입니다. 해당 `<p>`가 참으로 판명되면 `<e>` 표현식은 순서대로 평가되고 시퀀스의 마지막 표현식의 값이 `cond`의 값으로 반환됩니다. 그러나 `if` 표현식에서는 `<consequent>`와 `<alternative>`가 단일 표현식이어야 합니다.]

`<`, `=`, `>`와 같은 기본 서술어 외에도 복합 서술어를 구성할 수 있는 논리적 합성 연산이 있습니다.가장 자주 사용되는 세 가지는 다음과 같습니다.

- `(and ⟨e₁⟩ … ⟨eₙ⟩)`
    
    인터프리터는 왼쪽에서 오른쪽 순서로 한 번에 하나씩 `<e>` 표현식을 평가합니다.어떤 `<e>`라도 거짓으로 평가되면 `and` 표현식의 값은 거짓이고 나머지 `<e>`는 평가되지 않습니다.모든 `<e>`가 참 값으로 평가되면 `and` 표현식의 값은 마지막 `<e>`의 값입니다.
    
- `(or ⟨e₁⟩ … ⟨eₙ⟩)`
    
    인터프리터는 왼쪽에서 오른쪽 순서로 한 번에 하나씩 `<e>` 표현식을 평가합니다.어떤 `<e>`라도 참 값으로 평가되면 해당 값이 `or` 표현식의 값으로 반환되고 나머지 `<e>`는 평가되지 않습니다.모든 `<e>`가 거짓으로 평가되면 `or` 표현식의 값은 거짓입니다.
    
- `(not ⟨e⟩)`
    
    `not` 표현식의 값은 표현식 `<e>`가 거짓으로 평가될 때 참이고, 그렇지 않으면 거짓입니다.
    

`and`와 `or`는 하위 표현식이 반드시 모두 평가되는 것은 아니므로 프로시저가 아닌 특별 형식이라는 점에 유의하십시오.`Not`은 일반 프로시저입니다.

이것들이 어떻게 사용되는지에 대한 예로, 숫자 x가 $5 \< x \< 10$ 범위에 있다는 조건은 다음과 같이 표현될 수 있습니다.

코드 스니펫

```
(and (> x 5) (< x 10))
```

또 다른 예로, 한 숫자가 다른 숫자보다 크거나 같은지 테스트하는 서술어를 다음과 같이 정의할 수 있습니다.

코드 스니펫

```
(define (>= x y) 
  (or (> x y) (= x y)))
```

또는 다음과 같이 정의할 수도 있습니다.

코드 스니펫

```
(define (>= x y) 
  (not (< x y)))
```

**연습 문제 1.1:** 다음은 표현식의 시퀀스입니다. 각 표현식에 대해 인터프리터가 출력하는 결과는 무엇입니까? 시퀀스는 제시된 순서대로 평가된다고 가정합니다.

코드 스니펫

```
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (> b a) b a))
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
```

**연습 문제 1.2:** 다음 표현식을 전위 형식으로 번역하십시오.

$$\frac{5 + 4 + (2 - (3 - (6 + \frac{4}{5})))}{3(6 - 2)(2 - 7)}.$$

**연습 문제 1.3:** 세 개의 숫자를 인수로 받아 두 개의 더 큰 숫자의 제곱의 합을 반환하는 프로시저를 정의하십시오.

**연습 문제 1.4:** 평가 모델은 연산자가 복합 표현식인 조합을 허용한다는 점에 유의하십시오. 이 관찰을 사용하여 다음 프로시저의 동작을 설명하십시오.

코드 스니펫

```
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

**연습 문제 1.5:** Ben Bitdiddle은 자신이 사용하는 인터프리터가 적용 순서 평가를 사용하는지 또는 정규 순서 평가를 사용하는지 확인하기 위한 테스트를 고안했습니다. 그는 다음 두 프로시저를 정의합니다.

코드 스니펫

```
(define (p) (p))

(define (test x y) 
  (if (= x 0) 
      0 
      y))
```

그런 다음 그는 다음 표현식을 평가합니다.

코드 스니펫

```
(test 0 (p))
```

적용 순서 평가를 사용하는 인터프리터에서 Ben은 어떤 동작을 관찰할까요? 정규 순서 평가를 사용하는 인터프리터에서 그는 어떤 동작을 관찰할까요? 답을 설명하십시오. (특별 형식 `if`에 대한 평가 규칙은 인터프리터가 정규 순서 또는 적용 순서를 사용하든지 동일하다고 가정합니다. 즉, 서술어 표현식이 먼저 평가되고, 그 결과에 따라 결과 표현식을 평가할지 대안 표현식을 평가할지 결정됩니다.)

## 1.1.7 예시: 뉴턴 방법으로 제곱근 구하기

위에서 소개된 프로시저는 일반적인 수학 함수와 매우 유사합니다.하나 이상의 매개변수에 의해 결정되는 값을 지정합니다.그러나 수학 함수와 컴퓨터 프로시저 사이에는 중요한 차이점이 있습니다.프로시저는 효과적이어야 합니다.

예를 들어, 제곱근을 계산하는 문제를 생각해 봅시다.제곱근 함수를 다음과 같이 정의할 수 있습니다.

$$\sqrt{x}\;\; = \;\;{\text{the}\;\; y}\;\;\text{such\ that}\;\;{y \geq 0}\;\;{\text{and}\;\; y^{2} = x.}$$

이것은 완벽하게 합법적인 수학 함수를 설명합니다.이를 사용하여 한 숫자가 다른 숫자의 제곱근인지 인식하거나 일반적으로 제곱근에 대한 사실을 도출할 수 있습니다.반면에 이 정의는 프로시저를 설명하지 않습니다.실제로 주어진 숫자의 제곱근을 실제로 찾는 방법에 대해서는 거의 아무것도 알려주지 않습니다.이 정의를 의사 Lisp로 다시 표현해도 도움이 되지 않습니다.

코드 스니펫

```
(define (sqrt x)
  (the y (and (>= y 0) 
              (= (square y) x))))
```

이것은 단순히 질문을 회피하는 것일 뿐입니다.

함수와 프로시저의 대조는 사물의 속성을 설명하는 것과 사물을 하는 방법을 설명하는 것 사이의 일반적인 구분을 반영하며, 때로는 선언적 지식과 명령적 지식 간의 구분이라고도 합니다.수학에서는 일반적으로 선언적(무엇이 있는가) 설명에 관심이 있는 반면, 컴퓨터 과학에서는 일반적으로 명령적(어떻게 하는가) 설명에 관심이 있습니다.^[선언적 및 명령적 설명은 수학과 컴퓨터 과학과 마찬가지로 밀접하게 관련되어 있습니다. 예를 들어, 프로그램이 생성하는 답이 "올바르다"고 말하는 것은 프로그램에 대한 선언적 진술입니다. 프로그램이 올바르다는 것을 증명하는 기술을 확립하는 것을 목표로 하는 많은 연구가 있으며, 이 주제의 기술적 어려움의 상당 부분은 명령적 진술(프로그램이 구성되는)과 선언적 진술(추론에 사용될 수 있는) 사이의 전환을 협상하는 것과 관련이 있습니다. 관련하여 프로그래밍 언어 설계의 중요한 현재 영역은 프로그래머가 지정한 "무엇이 있는가" 지식을 통해 "어떻게 하는가" 지식을 자동으로 생성할 수 있을 만큼 인터프리터를 정교하게 만드는 소위 초고수준 언어 탐색입니다. 이는 일반적으로 수행될 수 없지만, 진전이 이루어진 중요한 영역이 있습니다. 이 아이디어는 [제4장](https://www.google.com/search?q=Chapter-4.xhtml%23Chapter-4)에서 다시 다룰 것입니다.]

제곱근은 어떻게 계산할까요? 가장 일반적인 방법은 뉴턴의 연속 근사법을 사용하는 것입니다. 이 방법은 숫자 x의 제곱근에 대한 추측 y가 있을 때, y와 x/y의 평균을 구하여 더 나은 추측(실제 제곱근에 더 가까운 추측)을 얻기 위한 간단한 조작을 수행할 수 있다고 말합니다.^[이 제곱근 알고리즘은 사실 뉴턴 방법의 특수한 경우로, 방정식의 근을 찾는 일반적인 기술입니다. 제곱근 알고리즘 자체는 기원후 1세기에 알렉산드리아의 헤론에 의해 개발되었습니다. [1.3.4](https://www.google.com/search?q=1_002e3.xhtml%23g_t1_002e3_002e4)에서 일반적인 뉴턴 방법을 Lisp 프로시저로 표현하는 방법을 배울 것입니다.]예를 들어, 2의 제곱근을 다음과 같이 계산할 수 있습니다.초기 추측이 1이라고 가정합니다.

코드 스니펫

```
추측     몫      평균

1         (2/1)  = 2    ((2 + 1)/2)  = 1.5

1.5       (2/1.5)       ((1.3333 + 1.5)/2)
            = 1.3333      = 1.4167

1.4167    (2/1.4167)    ((1.4167 + 1.4118)/2) 
            = 1.4118      = 1.4142  

1.4142    ...           ...
```

이 과정을 계속하면 제곱근에 대한 더 나은 근사치를 얻게 됩니다.

이제 프로시저 측면에서 프로세스를 형식화해 보겠습니다.피재수(제곱근을 계산하려는 숫자)와 추측 값을 시작으로 합니다.추측이 우리 목적에 충분히 좋으면 완료된 것입니다.그렇지 않으면 개선된 추측으로 프로세스를 반복해야 합니다.이 기본 전략을 다음과 같이 프로시저로 작성합니다.

코드 스니펫

```
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
```

추측은 피재수와 이전 추측의 몫을 평균하여 개선됩니다.

코드 스니펫

```
(define (improve guess x)
  (average guess (/ x guess)))
```

여기서

코드 스니펫

```
(define (average x y) 
  (/ (+ x y) 2))
```

또한 "충분히 좋다"는 것이 무엇을 의미하는지 말해야 합니다.다음은 설명을 위해 적절하지만 실제로는 그리 좋은 테스트는 아닙니다.([연습 문제 1.7](https://www.google.com/search?q=%23Exercise-1_002e7) 참조.)아이디어는 답이 제곱이 피재수와 미리 정해진 허용 오차(여기서는 0.001)보다 작게 차이 날 만큼 충분히 가까워질 때까지 답을 개선하는 것입니다.^[서술어에 의문 부호로 끝나는 이름을 붙이는 것이 일반적입니다. 이는 서술어임을 기억하는 데 도움이 됩니다. 이는 단순히 스타일적인 규칙일 뿐입니다. 인터프리터 입장에서는 의문 부호는 평범한 문자일 뿐입니다.]

코드 스니펫

```
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
```

마지막으로, 시작할 방법이 필요합니다.예를 들어, 항상 어떤 숫자의 제곱근도 1이라고 추측할 수 있습니다.^[초기 추측을 1.0이 아니라 1로 표현한다는 점에 유의하십시오. 이는 많은 Lisp 구현에서는 아무런 차이도 만들지 않을 것입니다. 그러나 MIT Scheme은 정확한 정수와 십진수 값을 구별하며, 두 정수를 나누면 십진수가 아니라 유리수가 생성됩니다. 예를 들어, 10을 6으로 나누면 5/3이 생성되는 반면, 10.0을 6.0으로 나누면 1.6666666666666667이 생성됩니다. ([2.1.1](https://www.google.com/search?q=2_002e1.xhtml%23g_t2_002e1_002e1)에서 유리수에 대한 산술을 구현하는 방법을 배울 것입니다.) 제곱근 프로그램에서 초기 추측을 1로 시작하고 x가 정확한 정수이면 제곱근 계산에서 생성되는 모든 후속 값은 십진수가 아니라 유리수가 됩니다. 유리수와 십진수에 대한 혼합 연산은 항상 십진수를 생성하므로 초기 추측을 1.0으로 시작하면 모든 후속 값이 십진수가 되도록 합니다.]

코드 스니펫

```
(define (sqrt x)
  (sqrt-iter 1.0 x))
```

이러한 정의를 인터프리터에 입력하면, 다른 프로시저를 사용하는 것처럼 `sqrt`를 사용할 수 있습니다.

코드 스니펫

```
(sqrt 9)
3.00009155413138

(sqrt (+ 100 37))
11.704699917758145

(sqrt (+ (sqrt 2) (sqrt 3)))
1.7739279023207892

(square (sqrt 1000))
1000.000369924366
```

`sqrt` 프로그램은 우리가 지금까지 도입한 간단한 절차적 언어가 C 또는 Pascal과 같은 언어로 작성할 수 있는 순수 수치 프로그램을 작성하기에 충분하다는 것을 보여줍니다.이는 우리가 언어에 컴퓨터에 반복적으로 작업을 수행하도록 지시하는 반복(루핑) 구문을 포함하지 않았기 때문에 놀랍게 보일 수 있습니다.`Sqrt-iter`는 반면에 평범한 프로시저 호출 능력 외에 특별한 구성 없이 반복이 어떻게 달성될 수 있는지를 보여줍니다.^[반복을 구현하기 위해 프로시저 호출을 사용하는 것과 관련된 효율성 문제에 대해 걱정하는 독자들은 [1.2.1](https://www.google.com/search?q=1_002e2.xhtml%23g_t1_002e2_002e1)의 "꼬리 재귀"에 대한 설명을 주목해야 합니다.]

**연습 문제 1.6:** Alyssa P. Hacker는 `if`가 왜 특별 형식으로 제공되어야 하는지 이해하지 못합니다. "왜 `cond`를 사용하여 일반 프로시저로 정의할 수 없나요?"라고 묻습니다. Alyssa의 친구 Eva Lu Ator는 이것이 실제로 가능하다고 주장하며, 새로운 버전의 `if`를 정의합니다.

코드 스니펫

```
(define (new-if predicate 
                then-clause 
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
```

에바는 앨리사에게 다음과 같이 프로그램을 시연합니다.

코드 스니펫

```
(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
```

기뻐하며 앨리사는 `new-if`를 사용하여 제곱근 프로그램을 다시 작성합니다.

코드 스니펫

```
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
```

앨리사가 이것을 사용하여 제곱근을 계산하려고 할 때 어떤 일이 발생할까요? 설명하십시오.

**연습 문제 1.7:** 제곱근 계산에 사용되는 `good-enough?` 테스트는 매우 작은 숫자의 제곱근을 찾는 데는 그다지 효과적이지 않을 것입니다. 또한 실제 컴퓨터에서는 산술 연산이 거의 항상 제한된 정밀도로 수행됩니다. 이로 인해 우리의 테스트는 매우 큰 숫자에 대해서도 부적절합니다. 이러한 진술을 설명하고, 테스트가 작고 큰 숫자에서 어떻게 실패하는지 보여주는 예시를 제시하십시오. `good-enough?`를 구현하는 대안적인 전략은 `guess`가 한 반복에서 다음 반복으로 어떻게 변하는지 관찰하고, 변화가 추측의 아주 작은 부분일 때 멈추는 것입니다. 이러한 종류의 종료 테스트를 사용하는 제곱근 프로시저를 설계하십시오. 이것이 작고 큰 숫자에서 더 잘 작동합니까?

**연습 문제 1.8:** 큐브 근에 대한 뉴턴 방법은 y가 x의 큐브 근의 근사치일 때, 더 나은 근사치는 값

$$\frac{{x/y^{2}} + 2y}{3}.$$

에 의해 주어진다는 사실에 기반합니다.이 공식을 사용하여 제곱근 프로시저와 유사한 큐브 근 프로시저를 구현하십시오.([1.3.4](https://www.google.com/search?q=1_002e3.xhtml%23g_t1_002e3_002e4)에서 이러한 제곱근 및 큐브 근 프로시저의 추상화로서 일반적인 뉴턴 방법을 구현하는 방법을 배울 것입니다.)

## 1.1.8 프로시저를 블랙박스 추상화로 사용하기

`Sqrt`는 상호 정의된 프로시저 세트로 정의된 프로세스의 첫 번째 예입니다. `sqrt-iter`의 정의가 _재귀적_이라는 점에 유의하십시오. 즉, 프로시저는 자신을 사용하여 정의됩니다.프로시저를 자신을 사용하여 정의할 수 있다는 아이디어가 혼란스러울 수 있습니다. 그러한 "순환" 정의가 어떻게 의미가 있을 수 있는지, 컴퓨터가 수행할 잘 정의된 프로세스를 어떻게 지정할 수 있는지 불분명해 보일 수 있습니다.이것은 [1.2](https://www.google.com/search?q=1_002e2.xhtml%23g_t1_002e2)에서 더 신중하게 다룰 것입니다.하지만 먼저 `sqrt` 예제가 보여주는 다른 중요한 점들을 고려해 봅시다.

제곱근을 계산하는 문제는 추측이 충분히 좋은지 판단하는 방법, 추측을 개선하는 방법 등 여러 하위 문제로 자연스럽게 나뉜다는 점에 유의하십시오.이러한 각 작업은 별도의 프로시저에 의해 수행됩니다.전체 `sqrt` 프로그램은 문제를 하위 문제로 분해한 것을 반영하는 프로시저들의 클러스터([그림 1.2](https://www.google.com/search?q=%23Figure-1_002e2) 참조)로 볼 수 있습니다.

![](./images/ch1-Z-G-6.gif)

그림 1.2: sqrt 프로그램의 절차적 분해.

이 분해 전략의 중요성은 단순히 프로그램을 부분으로 나누는 데 있는 것이 아닙니다.결국, 어떤 큰 프로그램이라도 부분으로 나눌 수 있습니다. 처음 10줄, 다음 10줄 등.오히려, 각 프로시저가 다른 프로시저를 정의하는 모듈로 사용될 수 있는 식별 가능한 작업을 수행한다는 것이 중요합니다.예를 들어, `square`를 사용하여 `good-enough?` 프로시저를 정의할 때, 우리는 `square` 프로시저를 "블랙박스"로 간주할 수 있습니다.그 순간에는 프로시저가 어떻게 결과를 계산하는지에 대해서는 관심이 없으며, 단지 제곱을 계산한다는 사실에만 관심이 있습니다.제곱이 어떻게 계산되는지에 대한 세부 사항은 나중에 고려하기 위해 억제될 수 있습니다.실제로, `good-enough?` 프로시저에 관한 한, `square`는 프로시저라기보다는 프로시저의 추상화, 즉 _절차적 추상화_라고 불리는 것입니다.이 추상화 수준에서는 제곱을 계산하는 어떤 프로시저도 동일하게 좋습니다.

따라서, 반환하는 값만을 고려하면, 숫자를 제곱하는 다음 두 프로시저는 구별할 수 없어야 합니다.각각 숫자 인수를 취하고 해당 숫자의 제곱을 값으로 생성합니다.^[이러한 프로시저 중 어느 것이 더 효율적인 구현인지조차 명확하지 않습니다. 이는 사용 가능한 하드웨어에 따라 달라집니다. "명확한" 구현이 덜 효율적인 기계도 있습니다. 매우 효율적인 방식으로 저장된 광범위한 로그 및 역로그 테이블을 가진 기계를 생각해 보십시오.]

코드 스니펫

```
(define (square x) (* x x))

(define (square x) 
  (exp (double (log x))))

(define (double x) (+ x x))
```

따라서 프로시저 정의는 세부 사항을 숨길 수 있어야 합니다.프로시저 사용자는 프로시저를 직접 작성하지 않고 다른 프로그래머로부터 블랙박스로 얻었을 수도 있습니다.사용자는 프로시저를 사용하기 위해 프로시저가 어떻게 구현되었는지 알 필요가 없습니다.

### 지역 이름

프로시저 사용자가 중요하게 생각하지 말아야 할 프로시저 구현의 한 가지 세부 사항은 구현자가 프로시저의 형식 매개변수에 대해 선택한 이름입니다.따라서 다음 프로시저는 구별할 수 없어야 합니다.

코드 스니펫

```
(define (square x) (* x x))
(define (square y) (* y y))
```

프로시저의 의미는 작성자가 사용한 매개변수 이름과 무관해야 한다는 이 원칙은 표면적으로는 자명해 보이지만, 그 결과는 심오합니다.가장 간단한 결과는 프로시저의 매개변수 이름이 프로시저 본문에 지역적이어야 한다는 것입니다.예를 들어, 제곱근 프로시저의 `good-enough?` 정의에서 `square`를 사용했습니다.

코드 스니펫

```
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
```

`good-enough?` 작성자의 의도는 첫 번째 인수의 제곱이 두 번째 인수와 주어진 허용 오차 내에 있는지 확인하는 것입니다.`good-enough?` 작성자가 `guess`라는 이름을 첫 번째 인수를 참조하는 데 사용했고 `x`를 두 번째 인수를 참조하는 데 사용했다는 것을 알 수 있습니다.`square`의 인수는 `guess`입니다.만약 `square` 작성자가 `x`(위와 같이)를 해당 인수를 참조하는 데 사용했다면, `good-enough?`의 `x`는 `square`의 `x`와 다른 `x`여야 합니다.프로시저 `square`를 실행하는 것이 `good-enough?`가 사용하는 `x`의 값에 영향을 미치지 않아야 합니다. 왜냐하면 `square`가 계산을 마친 후 `good-enough?`에 의해 `x`의 값이 필요할 수 있기 때문입니다.

매개변수가 각 프로시저의 본문에 지역적이지 않았다면, `square`의 매개변수 `x`가 `good-enough?`의 매개변수 `x`와 혼동될 수 있었고, `good-enough?`의 동작은 우리가 사용한 `square` 버전에 따라 달라졌을 것입니다.따라서 `square`는 우리가 원했던 블랙박스가 아닐 것입니다.

프로시저의 형식 매개변수는 프로시저 정의에서 매우 특별한 역할을 합니다.즉, 형식 매개변수의 이름이 무엇인지는 중요하지 않습니다.이러한 이름을 _바인딩된 변수_라고 하며, 프로시저 정의가 형식 매개변수를 _바인딩한다_고 말합니다.바인딩된 변수가 정의 전체에서 일관되게 이름이 변경되면 프로시저 정의의 의미는 변경되지 않습니다.^[일관된 이름 변경의 개념은 실제로는 미묘하고 공식적으로 정의하기 어렵습니다. 유명한 논리학자들이 여기서 당황스러운 오류를 범했습니다.]변수가 바인딩되지 않은 경우 _자유_라고 말합니다.바인딩이 이름을 정의하는 표현식 집합을 해당 이름의 _스코프_라고 합니다.프로시저 정의에서 프로시저의 형식 매개변수로 선언된 바인딩된 변수는 프로시저의 본문을 자신의 스코프로 가집니다.

위 `good-enough?`의 정의에서 `guess`와 `x`는 바인딩된 변수이지만, `<`, `-`, `abs`, `square`는 자유 변수입니다.`good-enough?`의 의미는 `guess`와 `x`에 대해 우리가 선택하는 이름이 다르면서 `<`, `-`, `abs`, `square`와 다르다면 독립적이어야 합니다.(만약 `guess`를 `abs`로 이름을 바꿨다면, `abs` 변수를 _캡처_하여 버그를 발생시켰을 것입니다.이는 자유 변수에서 바인딩된 변수로 바뀌었을 것입니다.)그러나 `good-enough?`의 의미는 자유 변수의 이름과 무관하지 않습니다.이는 분명히 `abs` 기호가 숫자의 절댓값을 계산하는 프로시저를 이름 짓는다는 사실(이 정의 외부의 사실)에 의존합니다.`good-enough?`는 정의에서 `abs`를 `cos`로 대체하면 다른 함수를 계산할 것입니다.

### 내부 정의 및 블록 구조

지금까지 우리는 한 가지 종류의 이름 격리만 사용할 수 있습니다.프로시저의 형식 매개변수는 프로시저의 본문에 지역적입니다.제곱근 프로그램은 우리가 이름을 사용하는 방식을 제어하고 싶은 또 다른 방법을 보여줍니다.기존 프로그램은 별도의 프로시저로 구성됩니다.

코드 스니펫

```
(define (sqrt x) 
  (sqrt-iter 1.0 x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (improve guess x)
  (average guess (/ x guess)))
```

이 프로그램의 문제점은 `sqrt` 사용자가 중요하게 생각하는 유일한 프로시저가 `sqrt`라는 것입니다.다른 프로시저(`sqrt-iter`, `good-enough?`, `improve`)는 그들의 마음을 어지럽힐 뿐입니다.그들은 제곱근 프로그램과 함께 작동하기 위해 `good-enough?`라는 다른 프로시저를 다른 프로그램의 일부로 정의할 수 없습니다. 왜냐하면 `sqrt`가 그것을 필요로 하기 때문입니다.이 문제는 특히 많은 별도의 프로그래머가 대규모 시스템을 구축할 때 심각합니다.예를 들어, 대규모 수치 프로시저 라이브러리를 구축할 때 많은 수치 함수는 연속 근사치로 계산되므로 `good-enough?` 및 `improve`라는 보조 프로시저를 가질 수 있습니다.우리는 보조 프로시저를 `sqrt` 내부에 숨겨서 `sqrt`가 다른 연속 근사치와 공존할 수 있도록 각자 자신의 `good-enough?` 프로시저를 가질 수 있도록 하고 싶습니다.이를 가능하게 하기 위해 프로시저가 해당 프로시저에 지역적인 내부 정의를 가질 수 있도록 합니다.예를 들어, 제곱근 문제에서 우리는 다음과 같이 작성할 수 있습니다.

코드 스니펫

```
(define (sqrt x)
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
```

_블록 구조_라고 불리는 이러한 정의 중첩은 가장 간단한 이름 패키징 문제에 대한 기본적으로 올바른 해결책입니다.그러나 여기에 더 나은 아이디어가 숨어 있습니다.보조 프로시저의 정의를 내부화하는 것 외에도 이를 단순화할 수 있습니다.`x`는 `sqrt`의 정의에서 바인딩되므로, `sqrt` 내부에 정의된 프로시저 `good-enough?`, `improve`, `sqrt-iter`는 `x`의 스코프 내에 있습니다.따라서 이러한 각 프로시저에 `x`를 명시적으로 전달할 필요가 없습니다.대신 `x`가 내부 정의에서 자유 변수가 되도록 허용합니다(아래 참조).그러면 `x`는 포함하는 프로시저 `sqrt`가 호출될 때의 인수로 값을 얻습니다.이러한 방식을 _어휘적 스코핑_이라고 합니다.^[어휘적 스코핑은 프로시저의 자유 변수가 포함하는 프로시저 정의에 의해 만들어진 바인딩을 참조하도록 지시합니다. 즉, 프로시저가 정의된 환경에서 조회됩니다. 이 장에서는 환경과 인터프리터의 상세한 동작을 연구할 때 이것이 어떻게 작동하는지 자세히 알아볼 것입니다.]

코드 스니펫

```
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
```

우리는 큰 프로그램을 다루기 쉬운 부분으로 나누는 데 도움이 되도록 블록 구조를 광범위하게 사용할 것입니다.^[내장 정의는 프로시저 본문의 맨 앞에 와야 합니다. 정의와 사용을 뒤섞는 프로그램을 실행한 결과에 대해서는 관리가 책임지지 않습니다.]블록 구조의 아이디어는 프로그래밍 언어 Algol 60에서 유래했습니다.이것은 대부분의 고급 프로그래밍 언어에 나타나며, 대규모 프로그램 구축을 조직하는 데 중요한 도구입니다.